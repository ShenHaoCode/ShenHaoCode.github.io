<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C# 委托</title>
      <link href="/2020/07/04/CSharpDelegate/"/>
      <url>/2020/07/04/CSharpDelegate/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。</p><h3 id="将方法作为方法的参数"><a href="#将方法作为方法的参数" class="headerlink" title="将方法作为方法的参数"></a>将方法作为方法的参数</h3><p>我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 做某些额外的事情，比如初始化之类，此处略</span></span><br><span class="line">    EnglishGreeting(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Morning, "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。<br>现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"早上好, "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Language&#123;</span><br><span class="line">    English, Chinese</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, Language lang</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//做某些额外的事情，比如初始化之类，此处略</span></span><br><span class="line">    swith(lang)&#123;</span><br><span class="line">        <span class="keyword">case</span> Language.English:</span><br><span class="line">           EnglishGreeting(name);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Language.Chinese:</span><br><span class="line">           ChineseGreeting(name);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。<br>在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, Language lang</span>)</span></span><br></pre></td></tr></table></figure><p>我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。<br>如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MakeGreeting(name);</span><br></pre></td></tr></table></figure><p>好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, *** MakeGreeting</span>)</span>&#123;</span><br><span class="line">    MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：<strong>这个代表着方法的MakeGreeting参数应该是什么类型的？</strong></p><blockquote><p><strong>提示：</strong>这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。<br>聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br></pre></td></tr></table></figure><p>如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。<strong>MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。</strong><br>于是，委托出现了：<strong>它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。</strong></p><blockquote><p><strong>提示：</strong>如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的<strong>值的种类</strong>，也就是name参数的类型。<br>本例中委托的定义：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure><p>可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？<br>现在，让我们再次改动GreetPeople()方法，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>)</span>&#123;</span><br><span class="line">    MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义委托，它定义了可以代表的方法的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">"Morning, "</span> + name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">"早上好, "</span> + name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//注意此方法，它接受一个GreetingDelegate类型的方法作为参数</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>)</span> &#123;</span><br><span class="line">           MakeGreeting(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">           GreetPeople(<span class="string">"Jimmy Zhang"</span>, EnglishGreeting);</span><br><span class="line">           GreetPeople(<span class="string">"张子阳"</span>, ChineseGreeting);</span><br><span class="line">           Console.ReadKey();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure><p>我们现在对委托做一个总结：<br><strong>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</strong></p><h3 id="将方法绑定到委托"><a href="#将方法绑定到委托" class="headerlink" title="将方法绑定到委托"></a>将方法绑定到委托</h3><p>看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">string</span> name1, name2;</span><br><span class="line">    name1 = <span class="string">"Jimmy Zhang"</span>;</span><br><span class="line">    name2 = <span class="string">"张子阳"</span>; </span><br><span class="line"></span><br><span class="line">    GreetPeople(name1, EnglishGreeting);</span><br><span class="line">    GreetPeople(name2, ChineseGreeting);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingDelegate delegate1, delegate2;</span><br><span class="line">    delegate1 = EnglishGreeting;</span><br><span class="line">    delegate2 = ChineseGreeting;</span><br><span class="line"></span><br><span class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);</span><br><span class="line">    GreetPeople(<span class="string">"张子阳"</span>, delegate2);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting; <span class="comment">// 先给委托类型的变量赋值</span></span><br><span class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);  </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure><p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting; <span class="comment">// 先给委托类型的变量赋值</span></span><br><span class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    delegate1 (<span class="string">"Jimmy Zhang"</span>);   </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。<br>注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。<br>我们也可以使用下面的代码来这样简化这一过程：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</span><br><span class="line">delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br></pre></td></tr></table></figure><p>看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate();</span><br><span class="line">delegate1 += EnglishGreeting;   <span class="comment">// 这次用的是 “+=”，绑定语法。</span></span><br><span class="line">delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br></pre></td></tr></table></figure><p>但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。<br><strong>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</span><br><span class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);  </span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    delegate1 -= EnglishGreeting; <span class="comment">//取消对EnglishGreeting方法的绑定</span></span><br><span class="line">    <span class="comment">// 将仅调用 ChineseGreeting </span></span><br><span class="line">    GreetPeople(<span class="string">"张子阳"</span>, delegate1); </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure><p>让我们再次对委托作个总结：<br><strong>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server Notes</title>
      <link href="/2020/07/03/SQLServerNotes/"/>
      <url>/2020/07/03/SQLServerNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h2><p>SQL Server 是Microsoft 公司推出的关系型数据库管理系统。<br>SQL 是用于访问和处理数据库的标准的计算机语言</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">-1</span>, <span class="keyword">GETDATE</span>())) + <span class="number">1</span>, <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">-1</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询上个月一号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">GETDATE</span>()), <span class="keyword">GETDATE</span>())<span class="comment">--查询上月月底</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">GETDATE</span>()) + <span class="number">1</span>, <span class="keyword">GETDATE</span>())<span class="comment">--查询本月一号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>())), <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询本月底</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>())) + <span class="number">1</span>, <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询下月一号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">2</span>, <span class="keyword">GETDATE</span>())), <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">2</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询下月月底</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT</span>(<span class="built_in">VARCHAR</span>(<span class="number">7</span>), <span class="keyword">GETDATE</span>(), <span class="number">120</span>)</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> [TransitTrade]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="comment">/****** Object:  UserDefinedFunction [dbo].[SplitToTable]    Script Date: 2018/4/10 9:30:25 ******/</span></span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- =============================================</span></span><br><span class="line"><span class="comment">-- Author: &lt;Author,,Name&gt;</span></span><br><span class="line"><span class="comment">-- Create date: &lt;Create Date,,2020-07-04&gt;</span></span><br><span class="line"><span class="comment">-- Description:&lt;Description,,拆分字符串&gt;</span></span><br><span class="line"><span class="comment">-- =============================================</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> [dbo].[FUN_SplitToTable]</span><br><span class="line">(</span><br><span class="line">    @SplitString <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>),</span><br><span class="line">    @Separator <span class="keyword">NVARCHAR</span>(<span class="number">10</span>) = <span class="string">''</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">RETURNS</span> @SplitStringsTable <span class="keyword">TABLE</span></span><br><span class="line">(</span><br><span class="line">    [<span class="keyword">ID</span>] <span class="built_in">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    [<span class="keyword">VALUE</span>] <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>) <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @CurrentIndex <span class="built_in">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> @NextIndex <span class="built_in">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> @ReturnText <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>);</span><br><span class="line">    <span class="keyword">SET</span> @CurrentIndex = <span class="number">1</span>;</span><br><span class="line">    WHILE @CurrentIndex &lt;= LEN(@SplitString)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">SET</span> @NextIndex = <span class="keyword">CHARINDEX</span>(@Separator, @SplitString, @CurrentIndex);</span><br><span class="line">        IF @NextIndex = 0 OR @NextIndex IS NULL</span><br><span class="line">        <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="keyword">SELECT</span> @NextIndex = <span class="keyword">LEN</span>(@SplitString) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">SELECT</span> @ReturnText = <span class="keyword">SUBSTRING</span>(@SplitString, @CurrentIndex, @NextIndex - @CurrentIndex);</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> @SplitStringsTable ( [<span class="keyword">VALUE</span>] ) <span class="keyword">VALUES</span> ( @ReturnText );</span><br><span class="line">            <span class="keyword">SELECT</span> @CurrentIndex = @NextIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">RETURN</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> SQL Server </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/26/hello-world/"/>
      <url>/2020/06/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
