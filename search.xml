<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发常用英语单词</title>
      <link href="/2020/08/04/CommonEnglishWords/"/>
      <url>/2020/08/04/CommonEnglishWords/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><ul><li>abstract 抽象的</li><li>abstract base class (ABC)抽象基类</li><li>abstract class 抽象类</li><li>abstraction 抽象、抽象物、抽象性</li><li>access 存取、访问</li><li>access function 访问函数</li><li>access level访问级别</li><li>account 账户</li><li>action 动作</li><li>activate 激活</li><li>active 活动的</li><li>actual parameter 实参</li><li>adapter 适配器</li><li>add-in 插件</li><li>address 地址</li><li>address space 地址空间</li><li>ADO(ActiveX Data Object)ActiveX数据对象</li><li>advanced 高级的</li><li>aggregation 聚合、聚集</li><li>algorithm 算法</li><li>alias 别名</li><li>align 排列、对齐</li><li>allocate 分配、配置</li><li>allocator分配器、配置器</li><li>angle bracket 尖括号</li><li>annotation 注解、评注</li><li>API (Application Programming Interface) 应用(程序)编程接口</li><li>appearance 外观</li><li>append 附加</li><li>application 应用、应用程序</li><li>application framework 应用程序框架</li><li>Approximate String Matching 模糊匹配</li><li>architecture 架构、体系结构</li><li>archive file 归档文件、存档文件</li><li>argument 参数。</li><li>array 数组</li><li>arrow operator 箭头操作符</li><li>assert(ion) 断言</li><li>assign 赋值</li><li>assignment 赋值、分配</li><li>assignment operator 赋值操作符</li><li>associated 相关的、相关联的</li><li>asynchronous 异步的</li><li>attribute 特性、属性</li><li>authentication service 验证服务</li><li>authorization 授权</li></ul><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><ul><li>background 背景、后台(进程)</li><li>backup 备份</li><li>backup device备份设备</li><li>backup file 备份文件</li><li>backward compatible 向后兼容、向下兼容</li><li>base class 基类</li><li>base type 基类型</li><li>batch 批处理</li><li>BCL (base class library)基类库</li><li>Bin Packing 装箱问题</li><li>binary 二进制</li><li>binding 绑定</li><li>bit 位</li><li>bitmap 位图</li><li>block 块、区块、语句块</li><li>boolean 布林值(真假值，true或false)</li><li>border 边框</li><li>bounds checking 边界检查</li><li>boxing 装箱、装箱转换</li><li>brace (curly brace) 大括号、花括号</li><li>bracket (square brakcet) 中括号、方括号</li><li>breakpoint 断点</li><li>browser applications 浏览器应用(程序)</li><li>browser-accessible application 可经由浏览器访问的应用程序</li><li>bug 缺陷错误</li><li>build 编连(专指编译和连接)</li><li>built-in 内建、内置</li><li>bus 总线</li><li>business 业务、商务(看场合)</li><li>business Logic 业务逻辑</li><li>business rules 业务规则</li><li>buttons 按钮</li><li>by/through 通过</li><li>byte 位元组(由8 bits组成)</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul><li>cache 高速缓存</li><li>calendar 日历</li><li>Calendrical Calculations 日期</li><li>call 调用</li><li>call operator 调用操作符</li><li>callback 回调</li><li>candidate key 候选键 (for database)</li><li>cascading delete 级联删除 (for database)</li><li>cascading update 级联更新 (for database)</li><li>casting 转型、造型转换</li><li>catalog 目录</li><li>chain 链(function calls)</li><li>character 字符</li><li>character format 字符格式</li><li>character set 字符集</li><li>check box 复选框</li><li>check button 复选按钮</li><li>CHECK constraints CHECK约束 (for database)</li><li>checkpoint 检查点 (for database)</li><li>child class 子类</li><li>CIL (common intermediate language)通用中间语言、通用中介语言</li><li>class 类</li><li>class declaration 类声明</li><li>class definition 类定义</li><li>class derivation list 类继承列表</li><li>class factory 类厂</li><li>class hierarchy 类层次结构</li><li>class library 类库</li><li>class loader 类装载器</li><li>class template 类模板</li><li>class template partial specializations 类模板部分特化</li><li>class template specializations 类模板特化</li><li>classification 分类</li><li>clause 子句</li><li>cleanup 清理、清除</li><li>CLI (Common Language Infrastructure) 通用语言基础设施</li><li>client 客户、客户端</li><li>client application 客户端应用程序</li><li>client area 客户区</li><li>client cursor 客户端游标 (for database)</li><li>client-server 客户机/服务器、客户端/服务器</li><li>clipboard 剪贴板</li><li>clone 克隆</li><li>CLS (common language specification) 通用语言规范</li><li>code access security 代码访问安全</li><li>code page 代码页</li><li>COFF (Common Object File Format) 通用对象文件格式</li><li>collection 集合</li><li>COM (Component Object Model) 组件对象模型</li><li>combo box 组合框</li><li>command line 命令行</li><li>comment 注释</li><li>commit 提交 (for database)</li><li>communication 通讯</li><li>compatible 兼容</li><li>compile time 编译期、编译时</li><li>compiler 编译器</li><li>component组件</li><li>composite index 复合索引、组合索引 (for database)</li><li>composite key 复合键、组合键 (for database)</li><li>composition 复合、组合</li><li>concept 概念</li><li>concrete具体的</li><li>concrete class 具体类</li><li>concurrency 并发、并发机制</li><li>configuration 配置、组态</li><li>Connected Components 连通分支</li><li>connection 连接 (for database)</li><li>connection pooling 连接池</li><li>console 控制台</li><li>constant 常量</li><li>Constrained and Unconstrained Optimization 最值问题</li><li>constraint 约束 (for database)</li><li>construct 构件、成分、概念、构造（for language）</li><li>constructor (ctor) 构造函数、构造器</li><li>container 容器</li><li>containment包容</li><li>context 环境、上下文</li><li>control 控件</li><li>cookie</li><li>copy 拷贝</li><li>CORBA 通用对象请求中介架构(Common Object Request Broker Architecture)</li><li>cover 覆盖、涵盖</li><li>create/creation 创建、生成</li><li>crosstab query 交叉表查询 (for database)</li><li>Cryptography 密码</li><li>CTS (common type system)通用类型系统</li><li>cube 多维数据集 (for database)</li><li>cursor 光标</li><li>cursor 游标 (for database)</li><li>custom 定制、自定义</li></ul><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><ul><li>data 数据</li><li>data connection 数据连接 (for database)</li><li>data dictionary 数据字典 (for database)</li><li>data file 数据文件 (for database)</li><li>data integrity 数据完整性 (for database)</li><li>data manipulation language (DML)数据操作语言(DML) (for database)</li><li>data member 数据成员、成员变量</li><li>data source 数据源 (for database)</li><li>Data source name (DSN) 数据源名称(DSN) (for database)</li><li>data structure数据结构</li><li>Data Structures 基本数据结构</li><li>data table 数据表 (for database)</li><li>data-bound 数据绑定 (for database)</li><li>database 数据库 (for database)</li><li>database catalog 数据库目录 (for database)</li><li>database diagram 数据关系图 (for database)</li><li>database file 数据库文件 (for database)</li><li>database object 数据库对象 (for database)</li><li>database owner 数据库所有者 (for database)</li><li>database project 数据库工程 (for database)</li><li>database role 数据库角色 (for database)</li><li>database schema 数据库模式、数据库架构 (for database)</li><li>database script 数据库脚本 (for database)</li><li>datagram 数据报文</li><li>dataset 数据集 (for database)</li><li>dataset 数据集 (for database)</li><li>DBMS (database management system)数据库管理系统 (for database)</li><li>DCOM (distributed COM)分布式COM</li><li>dead lock 死锁 (for database)</li><li>deallocate 归还</li><li>debug 调试</li><li>debugger 调试器</li><li>decay 退化</li><li>declaration 声明</li><li>default 缺省、默认值</li><li>DEFAULT constraint默认约束 (for database)</li><li>default database 默认数据库 (for database)</li><li>default instance 默认实例 (for database)</li><li>default result set 默认结果集 (for database)</li><li>defer 推迟</li><li>definition 定义</li><li>delegate 委托</li><li>delegation 委托</li><li>deploy 部署</li><li>derived class 派生类</li><li>design pattern 设计模式</li><li>destroy 销毁</li><li>destructor(dtor)析构函数、析构器</li><li>device 设备</li><li>DHTML (dynamic HyperText Markup Language)动态超文本标记语言</li><li>dialog 对话框</li><li>Dictionaries 字典</li><li>digest 摘要</li><li>digital 数字的</li><li>directive (编译)指示符</li><li>directory 目录</li><li>disassembler 反汇编器</li><li>DISCO (Discovery of Web Services)Web Services的查找</li><li>dispatch 调度、分派、派发</li><li>distributed computing 分布式计算</li><li>distributed query 分布式查询 (for database)</li><li>DNA (Distributed interNet Application) 分布式网间应用程序</li><li>document 文档</li><li>DOM (Document Object Model)文档对象模型</li><li>dot operator (圆)点操作符</li><li>double-byte character set (DBCS)双字节字符集(DBCS)</li><li>driver 驱动(程序)</li><li>DTD (document type definition) 文档类型定义</li><li>dump 转储</li><li>dump file 转储文件</li></ul><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><ul><li>e-business 电子商务</li><li>efficiency 效率</li><li>efficient 高效</li><li>encapsulation 封装</li><li>end user 最终用户</li><li>end-to-end authentication 端对端身份验证</li><li>engine 引擎</li><li>entity 实体</li><li>enum (enumeration) 枚举</li><li>enumerators 枚举成员、枚举器</li><li>equal 相等</li><li>equality 相等性</li><li>equality operator 等号操作符</li><li>error log 错误日志 (for database)</li><li>escape character 转义符、转义字符</li><li>escape code 转义码</li><li>evaluate 评估</li><li>event 事件</li><li>event driven 事件驱动的</li><li>event handler 事件处理器</li><li>evidence 证据</li><li>exception 异常</li><li>exception declaration 异常声明</li><li>exception handling 异常处理、异常处理机制</li><li>exception specification 异常规范</li><li>exception-safe 异常安全的</li><li>exit 退出</li><li>explicit 显式</li><li>explicit specialization 显式特化</li><li>explicit transaction 显式事务 (for database)</li><li>export 导出</li><li>expression 表达式</li></ul><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><ul><li>fat client 胖客户端</li><li>feature 特性、特征</li><li>fetch 提取</li><li>field 字段 (for database)</li><li>field 字段(java)</li><li>field length 字段长度 (for database)</li><li>file 文件</li><li>filter 筛选 (for database)</li><li>finalization 终结</li><li>finalizer 终结器</li><li>firewall 防火墙</li><li>flag 标记</li><li>flash memory 闪存</li><li>flush 刷新</li><li>font 字体</li><li>foreign key (FK) 外键(FK) (for database)</li><li>form 窗体</li><li>formal parameter 形参</li><li>forward declaration 前置声明</li><li>forward-only 只向前的</li><li>forward-only cursor 只向前游标 (for database)</li><li>framework 框架</li><li>full specialization 完全特化</li><li>function 函数</li><li>function call operator (即operator ()) 函数调用操作符</li><li>function object 函数对象</li><li>function template函数模板</li><li>functionality 功能</li><li>functor 仿函数</li></ul><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><ul><li>GC (Garbage collection) 垃圾回收(机制)、垃圾收集(机制)</li><li>generate 生成</li><li>generic 泛化的、一般化的、通用的</li><li>generic algorithm通用算法</li><li>genericity 泛型</li><li>getter (相对于 setter)取值函数</li><li>global 全局的</li><li>global object 全局对象</li><li>grant 授权 (for database)</li><li>group 组、群</li><li>group box 分组框</li><li>GUI 图形界面</li><li>GUID (Globally Unique Identifier) 全球唯一标识符</li></ul><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><ul><li>handle 句柄</li><li>handler 处理器</li><li>hard disk 硬盘</li><li>hard-coded 硬编码的</li><li>hard-copy 截屏图</li><li>hardware 硬件</li><li>hash table 散列表、哈希表</li><li>header file头文件</li><li>heap 堆</li><li>help file 帮助文件</li><li>hierarchical data 阶层式数据、层次式数据</li><li>hierarchy 层次结构、继承体系</li><li>high level 高阶、高层</li><li>hook 钩子</li><li>Host (application)宿主(应用程序)</li><li>hot key 热键</li><li>HTML (HyperText Markup Language) 超文本标记语言</li><li>HTTP (HyperText Transfer Protocol) 超文本传输协议</li><li>HTTP pipeline HTTP管道</li><li>hyperlink 超链接</li></ul><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><ul><li>icon 图标</li><li>IDE (Integrated Development Environment)集成开发环境</li><li>identifier 标识符</li><li>IDL (Interface Definition Language) 接口定义语言</li><li>idle time 空闲时间</li><li>if and only if当且仅当</li><li>IL (Intermediate Language) 中间语言、中介语言</li><li>image 图象</li><li>IME 输入法</li><li>immediate base 直接基类</li><li>immediate derived 直接派生类</li><li>immediate updating 即时更新 (for database)</li><li>implement 实现</li><li>implementation 实现、实现品</li><li>implicit 隐式</li><li>implicit transaction隐式事务 (for database)</li><li>import 导入</li><li>incremental update 增量更新 (for database)</li><li>Independent Set 独立集</li><li>index 索引 (for database)</li><li>infinite loop 无限循环</li><li>infinite recursive 无限递归</li><li>information 信息</li><li>inheritance 继承、继承机制</li><li>initialization 初始化</li><li>initialization list 初始化列表、初始值列表</li><li>initialize 初始化</li><li>inline 内联</li><li>inline expansion 内联展开</li><li>inner join 内联接 (for database)</li><li>instance 实例</li><li>instantiated 具现化、实体化(常应用于template)</li><li>instantiation 具现体、具现化实体(常应用于template)</li><li>integrate 集成、整合</li><li>integrity 完整性、一致性</li><li>integrity constraint完整性约束 (for database)</li><li>interacts 交互</li><li>interface 接口</li><li>interoperability 互操作性、互操作能力</li><li>interpreter 解释器</li><li>introspection 自省</li><li>invariants 不变性</li><li>invoke 调用</li><li>isolation level 隔离级别 (for database)</li><li>item 项、条款、项目</li><li>iterate 迭代</li><li>iteration 迭代(回圈每次轮回称为一个iteration)</li><li>iterative 反复的、迭代的</li><li>iterator 迭代器</li></ul><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><ul><li>JIT compilation JIT编译即时编译</li><li>Job Scheduling 工程安排</li></ul><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><ul><li>key 键 (for database)</li><li>key column 键列 (for database)</li></ul><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><ul><li>left outer join 左向外联接 (for database)</li><li>level 阶、层例</li><li>library 库</li><li>lifetime 生命期、寿命</li><li>Linear Programming 线性规划</li><li>link 连接、链接</li><li>linkage 连接、链接</li><li>linker 连接器、链接器</li><li>list 列表、表、链表</li><li>list box 列表框</li><li>literal constant 字面常数</li><li>livelock 活锁 (for database)</li><li>load 装载、加载</li><li>load balancing 负载平衡</li><li>loader 装载器、载入器</li><li>local 局部的</li><li>local object 局部对象</li><li>lock 锁</li><li>log 日志</li><li>login 登录</li><li>login security mode登录安全模式 (for database)</li><li>lookup table 查找表 (for database)</li><li>loop 循环</li><li>loose coupling 松散耦合</li><li>lvalue 左值</li></ul><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><ul><li>machine code 机器码、机器代码</li><li>macro 宏</li><li>maintain 维护</li><li>managed code 受控代码、托管代码</li><li>Managed Extensions 受控扩充件、托管扩展</li><li>managed object 受控对象、托管对象</li><li>manifest 清单</li><li>many-to-many relationship 多对多关系 (for database)</li><li>many-to-one relationship 多对一关系 (for database)</li><li>marshal 列集</li><li>Matching 匹配</li><li>member 成员</li><li>member access operator 成员取用运算子(有dot和arrow两种)</li><li>member function 成员函数</li><li>member initialization list成员初始值列表</li><li>memory 内存</li><li>memory leak 内存泄漏</li><li>menu 菜单</li><li>message 消息</li><li>message based 基于消息的</li><li>message loop 消息环</li><li>message queuing消息队列</li><li>metadata 元数据</li><li>metaprogramming元编程</li><li>method 方法</li><li>micro 微</li><li>middle tier 中间层</li><li>middleware 中间件</li><li>modeling 建模</li><li>modeling language 建模语言</li><li>modem 调制解调器</li><li>modifier 修饰字、修饰符</li><li>module 模块</li><li>most derived class最底层的派生类</li><li>mouse 鼠标</li><li>multi-tasking 多任务</li><li>multi-thread 多线程</li><li>multicast delegate 组播委托、多点委托</li><li>multithreaded server application 多线程服务器应用程序</li><li>multiuser 多用户</li><li>mutable 可变的</li><li>mutex 互斥元、互斥体</li></ul><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><ul><li>named parameter 命名参数</li><li>named pipe 命名管道</li><li>namespace 名字空间、命名空间</li><li>native 原生的、本地的</li><li>native code 本地码、本机码</li><li>nested class 嵌套类</li><li>nested query 嵌套查询 (for database)</li><li>nested table 嵌套表 (for database)</li><li>network 网络</li><li>network card 网卡</li><li>Network Flow 网络流</li></ul><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><ul><li>object 对象</li><li>object based 基于对象的</li><li>object model 对象模型</li><li>object oriented 面向对象的</li><li>ODBC data source ODBC数据源 (for database)</li><li>ODBC driver ODBC驱动程序 (for database)</li><li>one-to-many relationship 一对多关系 (for database)</li><li>one-to-one relationship 一对一关系 (for database)</li><li>operating system (OS) 操作系统</li><li>operation 操作</li><li>operator 操作符、运算符</li><li>option 选项</li><li>outer join 外联接 (for database)</li><li>overflow 上限溢位(相对于underflow)</li><li>overload 重载</li><li>override 覆写、重载、重新定义</li></ul><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><ul><li>package 包</li><li>packaging 打包</li><li>palette 调色板</li><li>parallel 并行</li><li>parameter 参数、形式参数、形参</li><li>parameter list 参数列表</li><li>parameterize 参数化</li><li>parent class 父类</li><li>parentheses 圆括弧、圆括号</li><li>parse 解析</li><li>parser 解析器</li><li>part 零件、部件</li><li>partial specialization 局部特化</li><li>pass by reference 引用传递</li><li>pass by value 值传递</li><li>pattern 模式</li><li>persistence 持久性</li><li>pixel 像素</li><li>placeholder 占位符</li><li>platform 平台</li><li>Point Location 位置查询</li><li>pointer 指针</li><li>polymorphism 多态</li><li>pooling 池化</li><li>pop up 弹出式</li><li>port 端口</li><li>postfix 后缀</li><li>precedence 优先序(通常用于运算子的优先执行次序)</li><li>prefix 前缀</li><li>preprocessor 预处理器</li><li>primary key (PK)主键(PK) (for database)</li><li>primary table 主表 (for database)</li><li>primitive type 原始类型</li><li>print 打印</li><li>printer 打印机</li><li>procedure 过程</li><li>process 进程</li><li>program 程序</li><li>programmer 程序员</li><li>programming编程、程序设计</li><li>progress bar 进度指示器</li><li>project 项目、工程</li><li>property 属性</li><li>protocol 协议</li><li>pseudo code伪码</li></ul><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ul><li>qualified 合格的</li><li>qualifier 修饰符</li><li>quality 质量</li><li>queue 队列</li></ul><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><ul><li>radio button 单选按钮</li><li>random number 随机数</li><li>Random Number Generation 随机数生成</li><li>range 范围、区间</li><li>rank 等级</li><li>raw 未经处理的</li><li>re-direction 重定向</li><li>readOnly只读</li><li>record 记录 (for database)</li><li>recordset 记录集 (for database</li><li>recursion —— 递归</li><li>recursive 递归</li><li>refactoring 重构</li><li>refer 引用、参考</li><li>reference 引用、参考</li><li>reflection 反射</li><li>refresh data 刷新数据 (for database)</li><li>register 寄存器</li><li>regular expression 正则表达式</li><li>relational database 关系数据库</li><li>remote 远程</li><li>remote request 远程请求</li><li>represent 表述，表现</li><li>resolution 解析过程</li><li>resolve 解析、决议</li><li>result set 结果集 (for database)</li><li>retrieve data 检索数据</li><li>return 返回</li><li>return type 返回类型</li><li>return value 返回值</li><li>revoke 撤销</li><li>right outer join 右向外联接 (for database)</li><li>robust 健壮</li><li>robustness 健壮性</li><li>roll back 回滚 (for database)</li><li>roll forward 前滚 (for database)</li><li>routine 例程</li><li>row 行 (for database)</li><li>rowset 行集 (for database)</li><li>RPC (remote procedure call)RPC(远程过程调用)</li><li>runtime 执行期、运行期、执行时、运行时</li><li>rvalue 右值</li></ul><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><ul><li>Satisfiability 可满足性</li><li>save 保存</li><li>savepoint 保存点 (for database)</li><li>SAX (Simple API for XML)</li><li>scalable 可伸缩的、可扩展的</li><li>schedule 调度</li><li>scheduler 调度程序</li><li>schema 模式、纲目结构</li><li>scope 作用域、生存空间</li><li>screen 屏幕</li><li>scroll bar滚动条</li><li>SDK (Software Development Kit)软件开发包</li><li>sealed class 密封类</li><li>search 查找</li><li>Searching 查找</li><li>semantics 语义</li><li>sequential container序列式容器</li><li>serial 串行</li><li>serialization/serialize 序列化</li><li>server 服务器、服务端</li><li>session 会话 (for database)</li><li>Set and String Problems 集合与串的问题</li><li>Set Cover 集合覆盖</li><li>Set Data Structures 集合</li><li>Set Packing 集合配置</li><li>setter 设值函数</li><li>side effect 副作用</li><li>signature 签名</li><li>single-threaded 单线程</li><li>slider滑块</li><li>slot 槽</li><li>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议</li><li>snapshot 截屏图</li><li>snapshot 快照 (for database)</li><li>SOAP (simple object access protocol) 简单对象访问协议</li><li>software 软件</li><li>Sorting 排序</li><li>source code 源码、源代码</li><li>specialization 特化</li><li>specification 规范、规格</li><li>splitter 切分窗口</li><li>SQL (Structured Query Language) 结构化查询语言 (for database)</li><li>stack 栈、堆栈</li><li>standard library 标准库</li><li>standard template library 标准模板库</li><li>stateless 无状态的</li><li>statement 语句、声明</li><li>static cursor 静态游标 (for database)</li><li>static SQL statements 静态SQL语句 (for database)</li><li>status bar 状态条</li><li>stored procedure 存储过程 (for database)</li><li>stream 流</li><li>string 字符串</li><li>String Matching 模式匹配</li><li>stub 存根</li><li>subobject子对象</li><li>subquery 子查询 (for database)</li><li>subscript operator 下标操作符</li><li>support 支持</li><li>suspend 挂起</li><li>symbol 记号</li><li>syntax 语法</li><li>system databases 系统数据库 (for database)</li><li>system tables 系统表 (for database)</li></ul><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><ul><li>table 表 (for database)</li><li>table-level constraint 表级约束 (for database)</li><li>target 标的,目标</li><li>task switch 工作切换</li><li>TCP (Transport Control Protocol) 传输控制协议</li><li>template 模板</li><li>temporary object 临时对象</li><li>temporary table 临时表 (for database)</li><li>text 文本</li><li>Text Compression 压缩</li><li>text file 文本文件</li><li>thin client 瘦客户端</li><li>third-party 第三方</li><li>thread 线程</li><li>thread-safe 线程安全的</li><li>throw 抛出、引发(常指发出一个exception)</li><li>trace 跟踪</li><li>transaction 事务 (for database)</li><li>transaction log 事务日志 (for database)</li><li>transaction rollback 事务回滚 (for database)</li><li>traverse 遍历</li><li>trigger 触发器 (for database)</li><li>type 类型</li></ul><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><ul><li>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成</li><li>UML (unified modeling language)统一建模语言</li><li>unary function 单参函数</li><li>unary operator 一元操作符</li><li>unboxing 拆箱、拆箱转换</li><li>underflow 下限溢位(相对于overflow)</li><li>Unicode 统一字符编码标准，采用双字节对字符进行编码</li><li>Union query 联合查询 (for database)</li><li>UNIQUE constraints UNIQUE约束 (for database)</li><li>unique index 唯一索引 (for database)</li><li>unmanaged code 非受控代码、非托管代码</li><li>unmarshal 散集</li><li>unqualified 未经限定的、未经修饰的</li><li>URI (Uniform Resource identifier) 统一资源标识符</li><li>URL (Uniform Resource Locator) 统一资源定位器</li><li>user 用户</li><li>user interface 用户界面</li></ul><h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><ul><li>value types 值类型</li><li>variable 变量</li><li>vector 向量(一种容器，有点类似array)</li><li>vendor 厂商</li><li>viable 可行的</li><li>video 视频</li><li>view 视图 (for database)</li><li>view 视图</li><li>virtual function 虚函数</li><li>virtual machine 虚拟机</li><li>virtual memory 虚拟内存</li></ul><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><ul><li>Web Services web服务</li><li>WHERE clause WHERE子句 (for database)</li><li>wildcard characters 通配符字符 (for database)</li><li>wildcard search 通配符搜索 (for database)</li><li>window 窗口</li><li>window function 窗口函数</li><li>window procedure 窗口过程</li><li>Windows authentication Windows身份验证</li><li>wizard 向导</li><li>word 单词</li><li>write enable 写启用 (for database)</li><li>write-only 只写</li><li>WSDL (Web Service Description Language)Web Service描述语言</li></ul><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><ul><li>XML (eXtensible Markup Language) 可扩展标记语言</li><li>XML Message Interface (XMI) XML消息接口</li><li>XSD (XML Schema Definition) XML模式定义语言</li><li>XSL (eXtensible Stylesheet Language) 可扩展样式表语言</li><li>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换</li><li>xxx based 基于xxx的</li><li>xxx oriented 面向xxx</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#</title>
      <link href="/2020/07/27/CSharpNotes/"/>
      <url>/2020/07/27/CSharpNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C# 简介"></a>C# 简介</h2><p>C# 是一个现代的、通用的、面向对象的编程语言，它是由微软（Microsoft）开发的，由 Ecma 和 ISO 核准认可的。<br>C# 是由 Anders Hejlsberg 和他的团队在 .Net 框架开发期间开发的。<br>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。<br>下面列出了 C# 成为一种广泛应用的专业语言的原因：</p><ul><li>现代的、通用的编程语言。</li><li>面向对象。</li><li>面向组件。</li><li>容易学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以在多种计算机平台上编译。</li><li>.Net 框架的一部分。</li></ul><p>虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。<br>下面列出 C# 一些重要的功能：</p><ul><li>布尔条件（Boolean Conditions）</li><li>自动垃圾回收（Automatic Garbage Collection）</li><li>标准库（Standard Library）</li><li>组件版本（Assembly Versioning）</li><li>属性（Properties）和事件（Events）</li><li>委托（Delegates）和事件管理（Events Management）</li><li>易于使用的泛型（Generics）</li><li>索引器（Indexers）</li><li>条件编译（Conditional Compilation）</li><li>简单的多线程（Multithreading）</li><li>LINQ 和 Lambda 表达式</li><li>集成 Windows</li></ul><h2 id="C-变量"><a href="#C-变量" class="headerlink" title="C# 变量"></a>C# 变量</h2><p>一个变量只不过是一个供程序操作的存储区的名字。在 C# 中，每个变量都有一个特定的类型，类型决定了变量的内存大小和布局。范围内的值可以存储在内存中，可以对变量进行一系列操作。<br>我们已经讨论了各种数据类型。C# 中提供的基本的值类型大致可以分为以下几类：</p><table><thead><tr><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>整数类型</td><td>sbyte、byte、short、ushort、int、uint、long、ulong 和 char</td></tr><tr><td>浮点型</td><td>float 和 double</td></tr><tr><td>十进制类型</td><td>decimal</td></tr><tr><td>布尔类型</td><td>true 或 false 值，指定的值</td></tr><tr><td>空类型</td><td>可为空值的数据类型</td></tr></tbody></table><h2 id="C-类"><a href="#C-类" class="headerlink" title="C# 类"></a>C# 类</h2><ul><li>类：具有相同的属性和功能的对象的抽象的集合</li><li>对象：一切事物皆对象，对象就是一个 自包含的实体，用一组可识别的特性和行为来标识</li></ul><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"喵"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p><strong>注意：</strong>这里的<code>class</code>是表示定义类的关键字，<code>Cat</code>就是类的名称，<code>Shout</code>就是类的方法。</p>          </div><p>注意事项：</p><ol><li>类名称首字母要大写。多个单词则各个首字母大写</li><li>对外公开的方法需要使用<code>public</code>修饰符</li></ol><p>实例：就是一个真实的对象,比如我们都是<strong>人</strong> ,而你和我其实就是<strong>人</strong>类的实例了，而实例化就是创建对象的过程，使用 <code>new</code> 关键字来创建</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat(); <span class="comment">//将Cat类实例化</span></span><br><span class="line">    MessageBox.Show(cat.Shout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p><strong>注意：</strong><code>Cat cat = new Cat();</code>其实做了两件事。”</p>          </div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat; <span class="comment">//声明一个Cat对象，对象名为cat</span></span><br><span class="line">cat = <span class="keyword">new</span> Cat(); <span class="comment">//将此cat对象实例化</span></span><br></pre></td></tr></table></figure><p><code>Cat</code> 实例化后，等同于出生了一只小猫 <code>cat</code> ，此时就可以让小猫 <code>cat.Shout()</code> 了，在任何需要小猫叫的地方都可以实例化它。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数又叫<strong>构造方法</strong>，其实就是对类进行初始化。构造方法与类名同名，无返回值，也不需要 <code>void</code>，在 <code>new</code> 时候调用</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗词</title>
      <link href="/2020/07/26/Poetry/"/>
      <url>/2020/07/26/Poetry/</url>
      
        <content type="html"><![CDATA[<h2 id="诗"><a href="#诗" class="headerlink" title="诗"></a>诗</h2><h3 id="行路难"><a href="#行路难" class="headerlink" title="行路难"></a>行路难</h3><p>【作者】李白<br>【朝代】唐<br>金樽清酒斗十千，玉盘珍羞直万钱。<br>停杯投箸不能食，拔剑四顾心茫然。<br>欲渡黄河冰塞川，将登太行雪满山。<br>闲来垂钓碧溪上，忽复乘舟梦日边。<br>行路难！行路难！多歧路，今安在？<br>长风破浪会有时，直挂云帆济沧海。</p><h3 id="登高"><a href="#登高" class="headerlink" title="登高"></a>登高</h3><p>【作者】杜甫<br>【朝代】唐<br>风急天高猿啸哀，渚清沙白鸟飞回。<br>无边落木萧萧下，不尽长江滚滚来。<br>万里悲秋常作客，百年多病独登台。<br>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p><h3 id="励学篇"><a href="#励学篇" class="headerlink" title="励学篇"></a>励学篇</h3><p>【作者】赵恒<br>【朝代】宋<br>富家不用买良田，书中自有千钟粟。<br>安居不用架高堂，书中自有黄金屋。<br>出门无车毋须恨，书中有马多如簇。<br>娶妻无媒毋须恨，书中有女颜如玉。<br>男儿欲遂平生志，勤向窗前读六经。</p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="出师表"><a href="#出师表" class="headerlink" title="出师表"></a>出师表</h3><p>【作者】诸葛亮<br>【朝代】三国时期<br>先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。<br>侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。<br>将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。<br>亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。<br>臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。<br>先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。<br>愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。<br>今当远离，临表涕零，不知所言。</p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
          <category> 诗词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2020/07/24/GitNotes/"/>
      <url>/2020/07/24/GitNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h2><ul><li>Git 是一个用C语言开发的开源分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li><li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</li></ul><h3 id="Git-诞生"><a href="#Git-诞生" class="headerlink" title="Git 诞生"></a>Git 诞生</h3><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：速度</p><ul><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统</p><h3 id="Git-与-SVN-区别"><a href="#Git-与-SVN-区别" class="headerlink" title="Git 与 SVN 区别"></a>Git 与 SVN 区别</h3><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。<br>如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。<br>Git 与 SVN 区别点：</p><ol><li>Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</li><li>Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn. .cvs 等的文件夹里。</li><li>Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</li><li>Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</li><li>Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li></ol><h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在Windows上使用Git，可以从Git官网直接 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a> ，然后按默认选项安装即可。<br>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。<br>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="Git-创建本地版本库"><a href="#Git-创建本地版本库" class="headerlink" title="Git 创建本地版本库"></a>Git 创建本地版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名<strong>Repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><div class="note warning">            <p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p>          </div><ol><li>进入到计算机某个磁盘(如D盘)并创建文件夹存放您的git项目仓库(如GitHub)　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:</span><br><span class="line">mkdir GitHub</span><br><span class="line"><span class="built_in">cd</span> GitHub</span><br></pre></td></tr></table></figure></li><li>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>此时会提示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/GitHub/.git/</span><br></pre></td></tr></table></figure><code>git init</code> 指初始化版本库,在当前目录下会有.git的目录，它是git进行跟踪和管理版本库，禁止删改此文件(如果没看到可能是您的电脑不显示隐藏文件,在命令行工具运行 <code>ls -ah</code>可查看)</li></ol><p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。<br>Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，如果要真正使用版本控制系统，就要以纯文本方式编写文件。<br>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><div class="note warning">            <p>使用Windows的童鞋要特别注意：<br>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载 <a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a> 代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p>          </div><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><p>现在我们编写一个readme.txt文件，内容如下：</p><div class="note ">            <p>Git is a version control system.<br>Git is free software.</p>          </div><p>一定要放到<code>GitHub</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。<br>把一个文件放到Git仓库只需要两步。</p><ol><li>用命令git add告诉Git，把文件添加到仓库：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</li><li>用命令git commit告诉Git，把文件提交到仓库：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"wrote a readme file"</span></span><br></pre></td></tr></table></figure>提示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line">1 file changed, 2 insertions(+)</span><br><span class="line">create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。<code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</li></ol><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为commit可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line">git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><h2 id="Git-Q-amp-A"><a href="#Git-Q-amp-A" class="headerlink" title="Git Q&amp;A"></a>Git Q&amp;A</h2><p>Q：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。<br>A：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</p><p>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec &#39;readme.txt&#39; did not match any files</code>。<br>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server 索引（Index）</title>
      <link href="/2020/07/23/SQLServerIndexNotes/"/>
      <url>/2020/07/23/SQLServerIndexNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="索引的简介"><a href="#索引的简介" class="headerlink" title="索引的简介"></a>索引的简介</h2><p>索引分为聚集索引和非聚集索引，数据库中的索引类似于一本书的目录，在一本书中通过目录可以快速找到你想要的信息，而不需要读完全书。</p><p>索引主要目的是提高了SQL Server系统的性能，加快数据的查询速度与减少系统的响应时间 。</p><p>但是索引对于提高查询性能也不是万能的，也不是建立越多的索引就越好。索引建少了，用 WHERE 子句找数据效率低，不利于查找数据。索引建多了，不利于新增、修改和删除等操作，因为做这些操作时，SQL SERVER 除了要更新数据表本身，还要连带立即更新所有的相关索引，而且过多的索引也会浪费硬盘空间。</p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>索引就类似于中文字典前面的目录，按照拼音或部首都可以很快的定位到所要查找的字。</p><ol><li><strong>唯一索引（UNIQUE）</strong>：每一行的索引值都是唯一的（创建了唯一约束，系统将自动创建唯一索引）</li><li><strong>主键索引</strong>：当创建表时指定的主键列，会自动创建主键索引，并且拥有唯一的特性。</li><li><strong>聚集索引（CLUSTERED）</strong>：聚集索引就相当于使用字典的拼音查找，因为聚集索引存储记录是物理上连续存在的，即拼音 a 过了后面肯定是 b 一样</li><li><strong>非聚集索引（NONCLUSTERED）</strong>：非聚集索引就相当于使用字典的部首查找，非聚集索引是逻辑上的连续，物理存储并不连续。</li></ol><p>PS：聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。</p><table><thead><tr><th>动作描述</th><th align="center">使用聚集索引</th><th align="center">使用非聚集索引</th></tr></thead><tbody><tr><td>外键列</td><td align="center">是</td><td align="center">是</td></tr><tr><td>主键列</td><td align="center">是</td><td align="center">是</td></tr><tr><td>列经常被分组排序(ORDER BY)</td><td align="center">是</td><td align="center">是</td></tr><tr><td>返回某范围内的数据</td><td align="center">是</td><td align="center">否</td></tr><tr><td>小数目的不同值</td><td align="center">是</td><td align="center">否</td></tr><tr><td>大数目的不同值</td><td align="center">否</td><td align="center">是</td></tr><tr><td>频繁更新的列</td><td align="center">否</td><td align="center">是</td></tr><tr><td>频繁修改索引列</td><td align="center">否</td><td align="center">是</td></tr><tr><td>一个或极少不同值</td><td align="center">否</td><td align="center">否</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> SQL Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL Server </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2020/07/13/RegularExpressionNotes/"/>
      <url>/2020/07/13/RegularExpressionNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ol><li><code>\</code> 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，<code>n</code> 匹配字符 “n”。<code>\n</code> 匹配一个换行符。序列 <code>\\</code> 匹配 “\“ 而 <code>\(</code> 则匹配 “(“。</li><li><code>^</code> 匹配输入字符串的开始位置。如果设置了RegExp 对象的 Multiline 属性，<code>^</code> 也匹配 <code>\n</code> 或 <code>\r</code> 之后的位置。</li><li><code>$</code> 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，<code>$</code> 也匹配 <code>\n</code> 或 <code>\r</code> 之前的位置。</li><li><code>*</code> 匹配前面的子表达式零次或多次。例如，<code>zo*</code> 能匹配 “z” 以及 “zoo”。<code>*</code> 等价于<code>{0,}</code>。</li><li><code>+</code> 匹配前面的子表达式一次或多次。例如，<code>zo+</code> 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。<code>+</code> 等价于 <code>{1,}</code>。</li><li><code>?</code> 匹配前面的子表达式零次或一次。例如，<code>do(es)?</code> 可以匹配 “do” 或 “does” 。<code>?</code> 等价于 <code>{0,1}</code>。</li></ol><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><h3 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">数字：^[0-9]*$</span><br><span class="line">n位的数字：^\d&#123;n&#125;$</span><br><span class="line">至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line">m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line">零和非零开头的数字：^(0|[1-9][0-9]*)$</span><br><span class="line">非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$</span><br><span class="line">正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line">有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line">有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$</span><br><span class="line">非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</span><br><span class="line">非零的负整数：^\-[1-9][]0-9*$ 或 ^-[1-9]\d*$</span><br><span class="line">非负整数：^\d+$ 或 ^[1-9]\d*|0$</span><br><span class="line">非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span><br><span class="line">非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br><span class="line">非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br><span class="line">正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br><span class="line">负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br><span class="line">浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure><h3 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br><span class="line">英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span><br><span class="line">长度为3-20的所有字符：^.&#123;3,20&#125;$</span><br><span class="line">由26个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line">由26个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line">由26个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line">由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span><br><span class="line">由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span><br><span class="line">中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br><span class="line">中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span><br><span class="line">可以输入含有^%&amp;&#39;,;&#x3D;?$\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\x22]+</span><br><span class="line">禁止输入含有~的字符：[^~\x22]+</span><br></pre></td></tr></table></figure><h3 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?</span><br><span class="line">InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$</span><br><span class="line">手机号码：^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\d&#123;8&#125;$</span><br><span class="line">电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span><br><span class="line">国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line">18位身份证号码(数字、字母x结尾)：^((\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$</span><br><span class="line">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$  </span><br><span class="line">日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br><span class="line">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span><br><span class="line">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ </span><br><span class="line"></span><br><span class="line">钱的输入格式：</span><br><span class="line">1. 有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ </span><br><span class="line">2. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ </span><br><span class="line">3. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ </span><br><span class="line">4. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ </span><br><span class="line">5. 必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ </span><br><span class="line">6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ </span><br><span class="line">7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ </span><br><span class="line">8. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ </span><br><span class="line">备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line"></span><br><span class="line">xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span><br><span class="line">中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line">双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br><span class="line">空白行的正则表达式：\n\s*\r    (可以用来删除空白行)</span><br><span class="line">HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\1&gt;|&lt;.*? &#x2F;&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line">首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line">腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)</span><br><span class="line">中国邮政编码：[1-9]\d&#123;5&#125;(?!\d)    (中国邮政编码为6位数字)</span><br><span class="line">IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)</span><br><span class="line">IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> RegEx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown 语法</title>
      <link href="/2020/07/10/MarkDownNotes/"/>
      <url>/2020/07/10/MarkDownNotes/</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>本页整理常用的 Markdown 语法，方便使用时随时查阅参考，会及时更新。</p><h2 id="标题段落"><a href="#标题段落" class="headerlink" title="标题段落"></a>标题段落</h2><p>中间空一行将分段落，会解析成<code>&lt;p&gt;</code>标签，换行会解析成<code>&lt;br&gt;</code>标签：</p><p>Paragraphs are separated<br>by a blank line.</p><p>Two spaces at the end of a line<br>produces a line break.</p><p>一般在文章中需要指定各层级的大纲和标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p><code>---</code> 可加分隔线</p><h2 id="字体显示"><a href="#字体显示" class="headerlink" title="字体显示"></a>字体显示</h2><table><thead><tr><th>代码</th><th>样式</th><th>备注</th></tr></thead><tbody><tr><td><code>*斜体*</code></td><td><em>斜体的内容</em></td><td></td></tr><tr><td><code>**粗体**</code></td><td><strong>粗体的内容</strong></td><td>表示强调</td></tr><tr><td><code>***斜体+粗体***</code></td><td><strong><em>斜体+粗体内容</em></strong></td><td></td></tr><tr><td><code>~~删除线~~</code></td><td><del>删除线内容</del></td><td></td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>apples</span><br><span class="line"><span class="bullet">* </span>oranges</span><br><span class="line"><span class="bullet">* </span>pears</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>apples</span><br><span class="line"><span class="bullet">- </span>oranges</span><br><span class="line"><span class="bullet">- </span>pears</span><br></pre></td></tr></table></figure><p>有序列表:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>lather</span><br><span class="line"><span class="bullet">2. </span>rinse</span><br><span class="line"><span class="bullet">3. </span>repeat</span><br></pre></td></tr></table></figure><p>多级列表在行前增加<code>&lt;tab&gt;</code></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>格式为<code>[链接文字](链接网址 &quot;标题&quot;)</code>，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://www.baidu.com "百度搜索"</span>)</span><br></pre></td></tr></table></figure><p>以下为新窗口打开：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)&#123;:target="_blank"&#125;</span><br></pre></td></tr></table></figure><p>效果为：</p><p><a href="https://www.baidu.com" target="_blank" rel="noopener" title="百度网">百度</a></p><p>另外，用 <code>&lt; &gt;</code> 包起来，网址和邮箱会自动加上链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">example.com</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">address@example.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果为：</p><p><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a><br><a href="mailto:&#97;&#x64;&#x64;&#114;&#x65;&#x73;&#x73;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#97;&#x64;&#x64;&#114;&#x65;&#x73;&#x73;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在技术文章中经常会需要描述相关代码，分成行内的代码命令和代码块，用反引号将代码包起来。</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从 <span class="code">`print('Hello world!')`</span> 开始代码之旅。</span><br></pre></td></tr></table></figure><p>(用<code>``</code>把代码括起来)</p><p>会显示成以下形式：</p><p>从 <code>print(&#39;Hello world!&#39;)</code>开始代码之旅。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块用以下格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">​<span class="code">```</span> 语言名称</span><br><span class="line">代码内容...</span><br><span class="line">​<span class="code">```</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```</span> Python</span><br><span class="line">w = 'Hello word!'</span><br><span class="line">print(w)</span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p>会输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="string">'Hello word!'</span></span><br><span class="line">print(w)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格一般显现结构化的内容，让内容更加有条理便于阅读和理解。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头 1 | 表头 2 |</span><br><span class="line">| ------ | ------ |</span><br><span class="line">| 列 1.1 | 列 2.1 |</span><br><span class="line">| 列 1.2 | 列 2.2 |</span><br></pre></td></tr></table></figure><p>最终效果是：</p><table><thead><tr><th>表头 1</th><th>表头 2</th></tr></thead><tbody><tr><td>列 1.1</td><td>列 2.1</td></tr><tr><td>列 1.2</td><td>列 2.2</td></tr></tbody></table><p>除此之外还可以定义当列的对齐方式，下边三列分别是左对齐、居中、右对齐：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here's this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>MD 为纯文本的输入方式，一般需要将图片传到服务器（或者图床，有些 MD 编辑器支持图片上传功能），然后再用 MD 代码进行显示处理，一般语法为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">/file/pic/2019/filename.jpg "title"</span>)</span><br><span class="line">![<span class="string">LOGO</span>](<span class="link">https://www.baidu.com/img/baidu_logo.gif "百度"</span>)</span><br></pre></td></tr></table></figure><p>最终效果是：</p><p><img src= "/img/loading.gif" data-src="https://www.baidu.com/img/baidu_logo.gif" alt="LOGO " title="百度"></p><p>图片的大小和样式，可以用 CSS 来控制，下文会讲到加 CSS 样式名。</p><h2 id="标签样式"><a href="#标签样式" class="headerlink" title="标签样式"></a>标签样式</h2><h3 id="样式名"><a href="#样式名" class="headerlink" title="样式名"></a>样式名</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容块如果需要样式，在内容之后加 &#123;.bg_txt&#125;</span><br></pre></td></tr></table></figure><p>会解析成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"bg_txt"</span>&gt;</span>有时候需要给内容引用样式，在内容之后加<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容块如果需要内联样式，在内容之后加 &#123;: style="float:right"&#125;</span><br></pre></td></tr></table></figure><p>会解析成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"float:right"</span>&gt;</span>内容块如果需要内联样式，在内容之后加<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性标签"><a href="#属性标签" class="headerlink" title="属性标签"></a>属性标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容块如果需要增加属性和值，可以在内容之后加 &#123;data=081414&#125;</span><br></pre></td></tr></table></figure><p>会解析成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">data</span>=<span class="string">'081414'</span>&gt;</span>内容块如果需要内联样式，在内容之后加<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="增加-ID"><a href="#增加-ID" class="headerlink" title="增加 ID"></a>增加 ID</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为这句话增加 ID &#123;: #custom-id&#125;</span><br></pre></td></tr></table></figure><p>会解析成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">'custom-id'</span>&gt;</span>为这句话增加 ID<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">/file/pic/2019/filename.jpg</span>)</span><br><span class="line"><span class="emphasis">*The caption for my image*</span> &#123;.center&#125;</span><br><span class="line"></span><br><span class="line">![<span class="string">alt</span>](<span class="link">/file/pic/2019/07/filename.jpg</span>) &#123;: style="float:right"&#125;</span><br><span class="line"></span><br><span class="line">![<span class="string">flower</span>](<span class="link">/image/flower.png</span>) &#123;:.center-image, height="300px", width="150px"&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 冬天到了，春天还会远吗？</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> MarkDown </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2020/07/07/RedisNotes/"/>
      <url>/2020/07/07/RedisNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是一个开源（BSD许可）、内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。<br>它支持字符串、哈希表、列表、集合、有序集合等数据类型。<br>内置复制、Lua脚本、LRU 收回、事务以及不同级别磁盘持久化功能，同时通过 Redis Sentinel 提供高可用，通过 Redis Cluster 提供自动分区。<br>在实际的开发过程中，多多少少都会涉及到缓存，而 Redis通常来说是我们分布式缓存的最佳选择。<br>Redis 也是我们熟知的NoSQL（非关系性数据库）之一，虽然其不能完全的替代关系性数据库，但它可作为其良好的补充。</p><h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><p>微服务以及分布式被广泛使用后，Redis 的使用场景就越来越多了，这里我罗列了主要的几种场景。</p><ol><li><strong>分布式缓存</strong>：在分布式的系统架构中，将缓存存储在内存中显然不当，因为缓存需要与其他机器共享，这时 <strong>Redis</strong> 便挺身而出了，缓存也是 <strong>Redis</strong> 使用最多的场景。</li><li><strong>分布式锁</strong>：在高并发的情况下，我们需要一个锁来防止并发带来的脏数据，Java 自带的锁机制显然对进程间的并发并不好使，此时可以利用 <strong>Redis</strong> 单线程的特性来实现我们的分布式。</li><li><strong>Session 存储/共享</strong>：Redis 可以将 Session 持久化到存储中，这样可以避免由于机器宕机而丢失用户会话信息。</li><li><strong>发布/订阅</strong>：Redis 还有一个发布/订阅的功能，您可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统。</li><li><strong>任务队列</strong>：Redis 的 lpush + brpop 命令组合即可实现阻塞队列，生产者客户端使用 lrpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式的”抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</li><li><strong>限速，接口访问频率限制</strong>：比如发送短信验证码的接口，通常为了防止别人恶意频刷，会限制用户每分钟获取验证码的频率，例如一分钟不能超过 5 次。</li></ol><p>当然 <strong>Redis</strong> 的使用场景并不仅仅只有这么多，还有很多未列出的场景，如计数、排行榜等，可见 <strong>Redis</strong> 的强大。不过 <strong>Redis</strong> 说到底还是一个数据库（非关系型），那么我们还是有必要了解一下它支持存储的数据结构。</p><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>前面也提到过，<strong>Redis</strong> 支持字符串、哈希表、列表、集合、有序集合五种数据类型的存储。了解这五种数据结构非常重要，可以说如果吃透了这五种数据结构，你就掌握了 <strong>Redis</strong> 应用知识的三分之一，下面我们就来逐一解析。</p><h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><strong>String</strong> 这种数据结构应该是我们最为常用的。在 <strong>Redis</strong> 中 <strong>String</strong> 表示的是一个可变的字节数组，我们初始化字符串的内容、可以拿到字符串的长度，可以获取 String 的子串，可以覆盖 String 的子串内容，可以追加子串。在 <strong>Redis</strong> 中我们初始化一个字符串时，会采用预分配冗余空间的方式来减少内存的频繁分配，实际分配的空间 capacity 一般要高于实际字符串长度 len。</p><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p>在 <strong>Redis</strong> 中列表 List 采用的存储结构是双向链表，由此可见其随机定位性能较差，比较适合首位插入删除。Redis 中的列表支持通过下标访问，不同的是 <strong>Redis</strong> 还为列表提供了一种负下标，-1 表示倒数一个元素，-2 表示倒数第二个数，依此类推。综合列表首尾增删性能优异的特点，通常我们使用 <code>rpush</code>/<code>rpop</code>/<code>lpush</code>/<code>lpop</code> 四条指令将列表作为队列来使用。在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。所以 <strong>Redis</strong> 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h3 id="哈希表（Hash）"><a href="#哈希表（Hash）" class="headerlink" title="哈希表（Hash）"></a>哈希表（Hash）</h3><p>Hash 与 Java 中的 HashMap 差不多，实现上采用二维结构，第一维是数组，第二维是链表。Hash 的 key 与 value 都存储在链表中，而数组中存储的则是各个链表的表头。在检索时，首先计算 key 的 hashcode，然后通过 hashcode 定位到链表的表头，再遍历链表得到 value 值。可能您比较好奇为啥要用链表来存储 key 和 value，直接用 key 和 value 一对一存储不就可以了吗？其实是因为有些时候我们无法保证 hashcode 值的唯一，若两个不同的 key 产生了相同的 hashcode，我们需要一个链表在存储两对键值对，这就是所谓的 hash 碰撞。</p><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>熟悉 Java 的同学应该知道 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。Redis 的 Set 结构也是一样，它的内部也使用 Hash 结构，所有的 value 都指向同一个内部值。</p><h3 id="有序集合（Sorted-Set）"><a href="#有序集合（Sorted-Set）" class="headerlink" title="有序集合（Sorted Set）"></a>有序集合（Sorted Set）</h3><p>有时也被称作 ZSet，是 <strong>Redis</strong> 中一个比较特别的数据结构，在有序集合中我们会给每个元素赋予一个权重，其内部元素会按照权重进行排序，我们可以通过命令查询某个范围权重内的元素，这个特性在我们做一个排行榜的功能时可以说非常实用了。其底层的实现使用了两个数据结构，hash 和跳跃列表，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。跳跃列表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><p>Redis有Windows和Linux两种环境安装，官网上下的是Statble版是Linux，大家一定要注意。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Redis下载地址: <a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a></p><h4 id="临时服务安装"><a href="#临时服务安装" class="headerlink" title="临时服务安装"></a>临时服务安装</h4><p>cmd敲命令进入Redis安装文件下，启动临时服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><p>如果出现一个方形图标，安装临时服务成功。</p><div class="note info">            <p><strong>注意：</strong>通过以上面命令，会创建Redis临时服务，不会在Window Service列表出现Redis服务名称和状态，此窗口关闭，服务会自动关闭。可以装一个Redis Management测试一下，当关闭这个临时服务是数据库连不上的。</p>          </div><p>现在进行客户端调用，因为只有临时服务，所以不要关闭上面窗口，我们打开文件夹下redis-cli.exe执行文件，进入客户端Dos窗口，敲入Set uid 1 返回OK ，表示写入内存中；我们再敲 Get uid，会返回一个Value值1。</p><h4 id="默认服务安装"><a href="#默认服务安装" class="headerlink" title="默认服务安装"></a>默认服务安装</h4><p>我们不可能每次要用Redis都去开一下临时服务，可不可以跟其它服务一样能够开机自启？当然是可以得，但是有点区别，后续会讲。进入Redis安装包文件下，敲入命令注册服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-install redis.windows.conf --loglevel verbose</span><br></pre></td></tr></table></figure><div class="note info">            <p><strong>注意：</strong>一定要把临时服务关闭，否则安装不上。</p>          </div><p>根据英文提示显然服务已经安装了，在Window Service列表中能看到，但是没启动，也无法手动启动，只有敲命令启动/暂停/卸载服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-start</span><br><span class="line">redis-server.exe --service-stop</span><br><span class="line">redis-server.exe --service-uninstall</span><br></pre></td></tr></table></figure><h4 id="自定义服务安装"><a href="#自定义服务安装" class="headerlink" title="自定义服务安装"></a>自定义服务安装</h4><p>所谓自定义服务安装，就是将服务重命名。进入Redis安装包文件下，注册服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-install redis.windows.conf --Service-name RedisServer1 --loglevel verbose</span><br></pre></td></tr></table></figure><div class="note info">            <p><strong>注意：</strong>通过以上面命令，会在Window  Service列表出现”RedisServer1”服务，但此服务不是启动状态，需要调下面命令启动服务。</p>          </div><p>与默认安装一样，唯一不同的就是在相应安装服务、启动、关闭、卸载服务时需要加上自定义Redis服务名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-start --Service-name RedisServer1</span><br><span class="line">redis-server.exe --service-stop --Service-name RedisServer1 </span><br><span class="line">redis-server.exe --service-uninstall --Service-name RedisServer1</span><br></pre></td></tr></table></figure><p>通过命令行卸载自定义服务后，电脑重启一下，卸载服务会全部完成。</p><h4 id="Redis主从服务安装"><a href="#Redis主从服务安装" class="headerlink" title="Redis主从服务安装"></a>Redis主从服务安装</h4><p>主从服务可以实现负载均衡，其实就是把上面Redis安装文件包，拷贝到相应目录，修改主、从服务器配置文件中IP、Port，同时从服务器要指定主服务器 的IP、Port，按照Redis自定义服务安装中命令进行服务安装、服务启动、服务关闭、服务卸载即可使用。</p><p>我本地主从服务器安装包都还是在D:\redis-win目录，文件夹Redis-x64-3.2.100为主服务，文件夹Redis-x64-3.2.100-2则是从服务，用的都是本地IP:127.0.0.1，生产环境大家可以根据自己实际情况进行设置。</p><p>主服务器（RedisServer1）redis.windows.conf修改如下：port 6379(默认)，不需要作修改。</p><p>从服务器（RedisServer2）redis.windows.conf修改如下：port 6380；slaveof  127.0.0.1 6379。</p><p>我们用RedisManagement分别进行两个端口连接做客户端，在主服务添加键可以同步到从服务，从服务添加无效。如果从服务没有配置从属关系，我们可以在Redis管理器中对从服务进行配置，打开控制台，输入slaveof 127.0.0.1 6379，效果一样。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们安装从服务时候，可以不通过配置文件来安装指定端口和指定主机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-install redis.windows.conf --Service-name RedisServer2 --loglevel verbose --port 6380</span><br></pre></td></tr></table></figure><p>这样也是指定端口安装。</p><p>运行从服务redis-cli.exe，这跟RedisManagement一样，也能配从属关系。我之所以没采用，因为我每次运行从服务出不了6380端口（仍是6379），但是我在Redis管理器中是可以连两个端口的服务，固没采用这种方法，网上很多教程说可以，我未实践成功！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 事件和委托 - Part.2</title>
      <link href="/2020/07/05/CSharpEventDelegate02/"/>
      <url>/2020/07/05/CSharpEventDelegate02/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如果你看过了 C#中的委托和事件 一文，我想你对委托和事件已经有了一个基本的认识。但那些远不是委托和事件的全部内容，还有很多的地方没有涉及。本文将讨论委托和事件一些更为细节的问题，包括一些大家常问到的问题，以及事件访问器、异常处理、超时处理和异步方法调用等内容。</p><h2 id="为什么要使用事件而不是委托变量？"><a href="#为什么要使用事件而不是委托变量？" class="headerlink" title="为什么要使用事件而不是委托变量？"></a>为什么要使用事件而不是委托变量？</h2><p>在 C#中的委托和事件 中，我提出了两个为什么在类型中使用事件向外部提供方法注册，而不是直接使用委托变量的原因。主要是从封装性和易用性上去考虑，但是还漏掉了一点，<strong>事件应该由事件发布者触发，而不应该由客户端（客户程序）来触发</strong>。这句话是什么意思呢？请看下面的范例：</p><div class="note info">            <p><strong>注意：</strong>注意这里术语的变化，当我们单独谈论事件，我们说发布者(publisher)、订阅者(subscriber)、客户端(client)。当我们讨论Observer模式，我们说主题(subject)和观察者(observer)。客户端通常是包含Main()方法的Program类。</p>          </div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber sub = <span class="keyword">new</span> Subscriber();</span><br><span class="line">        </span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> NumberChangedEventHandler(sub.OnNumberChanged);</span><br><span class="line">        pub.DoSomething();          <span class="comment">// 应该通过DoSomething()来触发事件</span></span><br><span class="line">        pub.NumberChanged(<span class="number">100</span>);     <span class="comment">// 但可以被这样直接调用，对委托变量的不恰当使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">NumberChangedEventHandler</span>(<span class="params"><span class="keyword">int</span> count</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> NumberChangedEventHandler NumberChanged;         <span class="comment">// 声明委托变量</span></span><br><span class="line">    <span class="comment">//public event NumberChangedEventHandler NumberChanged; // 声明一个事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里完成一些工作 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NumberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 触发事件</span></span><br><span class="line">            count++;</span><br><span class="line">            NumberChanged(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnNumberChanged</span>(<span class="params"><span class="keyword">int</span> count</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Subscriber notified: count = &#123;0&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个NumberChangedEventHandler委托，然后我们创建了事件的发布者Publisher和订阅者Subscriber。当使用委托变量时，客户端可以直接通过委托变量触发事件，也就是直接调用pub.NumberChanged(100)，这将会影响到所有注册了该委托的订阅者。而<strong>事件的本意应该为在事件发布者在其本身的某个行为中触发，比如说在方法DoSomething()中满足某个条件后触发</strong>。通过添加event关键字来发布事件，事件发布者的封装性会更好，<strong>事件仅仅是供其他类型订阅，而客户端不能直接触发事件（语句pub.NumberChanged(100)无法通过编译），事件只能在事件发布者Publisher类的内部触发（比如在方法pub.DoSomething()中），换言之，就是NumberChanged(100)语句只能在Publisher内部被调用</strong>。</p><p>大家可以尝试一下，将委托变量的声明那行代码注释掉，然后取消下面事件声明的注释。此时程序是无法编译的，当你使用了event关键字之后，直接在客户端触发事件这种行为，也就是直接调用pub.NumberChanged(100)，是被禁止的。事件只能通过调用DoSomething()来触发。这样才是事件的本意，事件发布者的封装才会更好。</p><p>就好像如果我们要定义一个数字类型，我们会使用int而不是使用object一样，给予对象过多的能力并不见得是一件好事，应该是越合适越好。尽管直接使用委托变量通常不会有什么问题，但它给了客户端不应具有的能力，而使用事件，可以限制这一能力，更精确地对类型进行封装。</p><div class="note info">            <p><strong>注意：</strong>这里还有一个约定俗称的规定，就是订阅事件的方法的命名，通常为“On事件名”，比如这里的OnNumberChanged。</p>          </div><h2 id="为什么委托定义的返回值通常都为void？"><a href="#为什么委托定义的返回值通常都为void？" class="headerlink" title="为什么委托定义的返回值通常都为void？"></a>为什么委托定义的返回值通常都为void？</h2><p>尽管并非必需，但是我们发现很多的委托定义返回值都为void，为什么呢？这是因为委托变量可以供多个订阅者注册，如果定义了返回值，那么多个订阅者的方法都会向发布者返回数值，结果就是后面一个返回的方法值将前面的返回值覆盖掉了，因此，实际上只能获得最后一个方法调用的返回值。可以运行下面的代码测试一下。除此以外，发布者和订阅者是松耦合的，发布者根本不关心谁订阅了它的事件、为什么要订阅，更别说订阅者的返回值了，所以返回订阅者的方法返回值大多数情况下根本没有必要。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> GeneralEventHandler(sub1.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> GeneralEventHandler(sub2.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> GeneralEventHandler(sub3.OnNumberChanged);</span><br><span class="line">        pub.DoSomething();          <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">GeneralEventHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> GeneralEventHandler NumberChanged; <span class="comment">// 声明一个事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (NumberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 触发事件</span></span><br><span class="line">            <span class="keyword">string</span> rtn = NumberChanged();</span><br><span class="line">            Console.WriteLine(rtn);     <span class="comment">// 打印返回的字符串，输出为Subscriber3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">OnNumberChanged</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Subscriber1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123; <span class="comment">/* 略，与上类似，返回Subscriber2*/</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123; <span class="comment">/* 略，与上类似，返回Subscriber3*/</span> &#125;</span><br></pre></td></tr></table></figure><p>如果运行这段代码，得到的输出是Subscriber3，可以看到，只得到了最后一个注册方法的返回值。</p><h2 id="如何让事件只允许一个客户订阅？"><a href="#如何让事件只允许一个客户订阅？" class="headerlink" title="如何让事件只允许一个客户订阅？"></a>如何让事件只允许一个客户订阅？</h2><p>少数情况下，比如像上面，为了避免发生“值覆盖”的情况（更多是在异步调用方法时，后面会讨论），我们可能想限制只允许一个客户端注册。此时怎么做呢？我们可以向下面这样，将事件声明为private的，然后提供两个方法来进行注册和取消注册：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">event</span> GeneralEventHandler NumberChanged;    <span class="comment">// 声明一个私有事件</span></span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">GeneralEventHandler method</span>)</span> &#123;</span><br><span class="line">        NumberChanged = method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">GeneralEventHandler method</span>)</span> &#123;</span><br><span class="line">        NumberChanged -= method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其余的事情</span></span><br><span class="line">        <span class="keyword">if</span> (NumberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 触发事件</span></span><br><span class="line">            <span class="keyword">string</span> rtn = NumberChanged();</span><br><span class="line">            Console.WriteLine(<span class="string">"Return: &#123;0&#125;"</span>, rtn);      <span class="comment">// 打印返回的字符串，输出为Subscriber3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p><strong>注意：</strong>注意上面，在UnRegister()中，没有进行任何判断就使用了NumberChanged-=method语句。这是因为即使method方法没有进行过注册，此行语句也不会有任何问题，不会抛出异常，仅仅是不会产生任何效果而已。</p>          </div><p>注意在Register()方法中，我们使用了赋值操作符“=”，而非“+=”，通过这种方式就避免了多个方法注册。上面的代码尽管可以完成我们的需要，但是此时大家还应该注意下面两点：</p><ol><li><p>将NumberChanged声明为委托变量还是事件都无所谓了，因为它是私有的，即便将它声明为一个委托变量，客户端也看不到它，也就无法通过它来触发事件、调用订阅者的方法。而只能通过Register()和UnRegister()方法来注册和取消注册，通过调用DoSomething()方法触发事件（而不是NumberChanged本身，这在前面已经讨论过了）。</p></li><li><p>我们还应该发现，这里采用的、对NumberChanged委托变量的访问模式和C#中的属性是多么类似啊？大家知道，在C#中通常一个属性对应一个类型成员，而在类型的外部对成员的操作全部通过属性来完成。尽管这里对委托变量的处理是类似的效果，但却使用了两个方法来进行模拟，有没有办法像使用属性一样来完成上面的例子呢？答案是有的，C#中提供了一种叫事件访问器（Event Accessor）的东西，它用来封装委托变量。如下面例子所示：</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged -= sub1.OnNumberChanged;  <span class="comment">// 不会有任何反应</span></span><br><span class="line">        pub.NumberChanged += sub2.OnNumberChanged;  <span class="comment">// 注册了sub2</span></span><br><span class="line">        pub.NumberChanged += sub1.OnNumberChanged;  <span class="comment">// sub1将sub2的覆盖掉了</span></span><br><span class="line">        </span><br><span class="line">        pub.DoSomething();          <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">GeneralEventHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个委托变量</span></span><br><span class="line">    <span class="keyword">private</span> GeneralEventHandler numberChanged;</span><br><span class="line">    <span class="comment">// 事件访问器的定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> GeneralEventHandler NumberChanged &#123;</span><br><span class="line">        <span class="keyword">add</span> &#123;</span><br><span class="line">            numberChanged = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">remove</span> &#123;</span><br><span class="line">            numberChanged -= <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        <span class="keyword">if</span> (numberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 通过委托变量触发事件</span></span><br><span class="line">            <span class="keyword">string</span> rtn = numberChanged();</span><br><span class="line">            Console.WriteLine(<span class="string">"Return: &#123;0&#125;"</span>, rtn);      <span class="comment">// 打印返回的字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">OnNumberChanged</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Subscriber1 Invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Subscriber1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;<span class="comment">/* 与上类同，略 */</span>&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;<span class="comment">/* 与上类同，略 */</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码中类似属性的public event GeneralEventHandler NumberChanged {add{…}remove{…}}语句便是事件访问器。使用了事件访问器以后，在DoSomething方法中便只能通过numberChanged委托变量来触发事件，而不能NumberChanged事件访问器（注意它们的大小写不同）触发，它只用于注册和取消注册。下面是代码输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1 Invoked!</span><br><span class="line"></span><br><span class="line">Return: Subscriber1</span><br></pre></td></tr></table></figure><h2 id="获得多个返回值与异常处理"><a href="#获得多个返回值与异常处理" class="headerlink" title="获得多个返回值与异常处理"></a>获得多个返回值与异常处理</h2><p>现在假设我们想要获得多个订阅者的返回值，以List<string>的形式返回，该如何做呢？我们应该记得委托定义在编译时会生成一个继承自MulticastDelegate的类，而这个MulticastDelegate又继承自Delegate，在Delegate内部，维护了一个委托链表，链表上的每一个元素，为一个只包含一个目标方法的委托对象。而通过Delegate基类的GetInvocationList()静态方法，可以获得这个委托链表。随后我们遍历这个链表，通过链表中的每个委托对象来调用方法，这样就可以分别获得每个方法的返回值：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program4</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub1.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub2.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub3.OnNumberChanged);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">string</span>&gt; list = pub.DoSomething();  <span class="comment">//调用方法，在方法内触发事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> str <span class="keyword">in</span> list) &#123;</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">DemoEventHandler</span>(<span class="params"><span class="keyword">int</span> num</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> DemoEventHandler NumberChanged;    <span class="comment">// 声明一个事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">string</span>&gt; <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事</span></span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">string</span>&gt; strList = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (NumberChanged == <span class="literal">null</span>) <span class="keyword">return</span> strList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得委托数组</span></span><br><span class="line">        Delegate[] delArray = NumberChanged.GetInvocationList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">            <span class="comment">// 进行一个向下转换</span></span><br><span class="line">            DemoEventHandler method = (DemoEventHandler)del;</span><br><span class="line">            strList.Add(method(<span class="number">100</span>));       <span class="comment">// 调用方法并获取返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">OnNumberChanged</span>(<span class="params"><span class="keyword">int</span> num</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Subscriber1 invoked, number:&#123;0&#125;"</span>, num);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subscriber1 returned]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;与上面类同，略&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;与上面类同，略&#125;</span><br></pre></td></tr></table></figure><p>如果运行上面的代码，可以得到这样的输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1 invoked, number:<span class="number">100</span></span><br><span class="line">Subscriber2 invoked, number:<span class="number">100</span></span><br><span class="line">Subscriber3 invoked, number:<span class="number">100</span></span><br><span class="line">[<span class="meta">Subscriber1 returned</span>]</span><br><span class="line">[<span class="meta">Subscriber2 returned</span>]</span><br><span class="line">[<span class="meta">Subscriber3 returned</span>]</span><br></pre></td></tr></table></figure><p>可见我们获得了三个方法的返回值。而我们前面说过，很多情况下委托的定义都不包含返回值，所以上面介绍的方法似乎没有什么实际意义。其实通过这种方式来触发事件最常见的情况应该是在异常处理中，因为很有可能在触发事件时，订阅者的方法会抛出异常，而这一异常会直接影响到发布者，使得发布者程序中止，而后面订阅者的方法将不会被执行。因此我们需要加上异常处理，考虑下面一段程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program5</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publisher pub = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub1.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub2.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub3.OnNumberChanged);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MyEvent(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Exception: &#123;0&#125;"</span>, e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Subscriber1 Invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Subscriber2 Failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;<span class="comment">/* 与Subsciber1类同，略*/</span>&#125;</span><br></pre></td></tr></table></figure><p>注意到我们在Subscriber2中抛出了异常，同时我们在Publisher中使用了try/catch语句来处理异常。运行上面的代码，我们得到的结果是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1 Invoked!</span><br><span class="line">Exception: Subscriber2 Failed</span><br></pre></td></tr></table></figure><p>可以看到，尽管我们捕获了异常，使得程序没有异常结束，但是却影响到了后面的订阅者，因为Subscriber3也订阅了事件，但是却没有收到事件通知（它的方法没有被调用）。此时，我们可以采用上面的办法，先获得委托链表，然后在遍历链表的循环中处理异常，我们只需要修改一下DoSomething方法就可以了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">        Delegate[] delArray = MyEvent.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">            EventHandler method = (EventHandler)del;    <span class="comment">// 强制转换为具体的委托类型</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                method(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Exception: &#123;0&#125;"</span>, e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到Delegate是EventHandler的基类，所以为了触发事件，先要进行一个向下的强制转换，之后才能在其上触发事件，调用所有注册对象的方法。除了使用这种方式以外，还有一种更灵活方式可以调用方法，它是定义在Delegate基类中的DynamicInvoke()方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">DynamicInvoke</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">object</span>[] args</span>)</span>;</span><br></pre></td></tr></table></figure><p>这可能是调用委托最通用的方法了，适用于所有类型的委托。它接受的参数为object[]，也就是说它可以将任意数量的任意类型作为参数，并返回单个object对象。上面的DoSomething()方法也可以改写成下面这种通用形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 做某些其他的事情</span></span><br><span class="line">    <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">        Delegate[] delArray = MyEvent.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;                    </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用DynamicInvoke方法触发事件</span></span><br><span class="line">                del.DynamicInvoke(<span class="keyword">this</span>, EventArgs.Empty);   </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Exception: &#123;0&#125;"</span>, e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意现在在DoSomething()方法中，我们取消了向具体委托类型的向下转换，现在没有了任何的基于特定委托类型的代码，而DynamicInvoke又可以接受任何类型的参数，且返回一个object对象。所以我们完全可以将DoSomething()方法抽象出来，使它成为一个公共方法，然后供其他类来调用，我们将这个方法声明为静态的，然后定义在Program类中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发某个事件，以列表形式返回所有方法的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">object</span>[] <span class="title">FireEvent</span>(<span class="params">Delegate del, <span class="keyword">params</span> <span class="keyword">object</span>[] args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="keyword">object</span>&gt; objList = <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (del != <span class="literal">null</span>) &#123;</span><br><span class="line">        Delegate[] delArray = del.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (Delegate method <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用DynamicInvoke方法触发事件</span></span><br><span class="line">                <span class="keyword">object</span> obj = method.DynamicInvoke(args);</span><br><span class="line">                <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">                    objList.Add(obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objList.ToArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后，我们在DoSomething()中只要简单的调用一下这个方法就可以了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 做某些其他的事情</span></span><br><span class="line">    Program5.FireEvent(MyEvent, <span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FireEvent()方法还可以返回一个object[]数组，这个数组包括了所有订阅者方法的返回值。而在上面的例子中，我没有演示如何获取并使用这个数组，为了节省篇幅，这里也不再赘述了，在本文附带的代码中，有关于这部分的演示，有兴趣的朋友可以下载下来看看。</p><h2 id="委托中订阅者方法超时的处理"><a href="#委托中订阅者方法超时的处理" class="headerlink" title="委托中订阅者方法超时的处理"></a>委托中订阅者方法超时的处理</h2><p>订阅者除了可以通过异常的方式来影响发布者以外，还可以通过另一种方式：超时。一般说超时，指的是方法的执行超过某个指定的时间，而这里我将含义扩展了一下，凡是方法执行的时间比较长，我就认为它超时了，这个“比较长”是一个比较模糊的概念，2秒、3秒、5秒都可以视为超时。超时和异常的区别就是超时并不会影响事件的正确触发和程序的正常运行，却会导致事件触发后需要很长才能够结束。在依次执行订阅者的方法这段期间内，客户端程序会被中断，什么也不能做。因为当执行订阅者方法时（通过委托，相当于依次调用所有注册了的方法），当前线程会转去执行方法中的代码，调用方法的客户端会被中断，只有当方法执行完毕并返回时，控制权才会回到客户端，从而继续执行下面的代码。我们来看一下下面一个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program6</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Publisher pub = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub1.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub2.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub3.OnEvent);</span><br><span class="line"></span><br><span class="line">        pub.DoSomething();      <span class="comment">// 触发事件</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"\nControl back to client!"</span>); <span class="comment">// 返回控制权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发某个事件，以列表形式返回所有方法的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">object</span>[] <span class="title">FireEvent</span>(<span class="params">Delegate del, <span class="keyword">params</span> <span class="keyword">object</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 代码与上同，略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        Console.WriteLine(<span class="string">"DoSomething invoked!"</span>);</span><br><span class="line">        Program6.FireEvent(MyEvent, <span class="keyword">this</span>, EventArgs.Empty); <span class="comment">//触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">3</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">"Waited for 3 seconds, subscriber1 invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Subscriber2 immediately Invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">"Waited for 2 seconds, subscriber2 invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们使用Thread.Sleep()静态方法模拟了方法超时的情况。其中Subscriber1.OnEvent()需要三秒钟完成，Subscriber2.OnEvent()立即执行，Subscriber3.OnEvent需要两秒完成。这段代码完全可以正常输出，也没有异常抛出（如果有，也仅仅是该订阅者被忽略掉），下面是输出的情况：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DoSomething invoked!</span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">3</span> seconds, subscriber1 invoked!</span><br><span class="line">Subscriber2 immediately Invoked!</span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">2</span> seconds, subscriber2 invoked!</span><br><span class="line"></span><br><span class="line">Control back to client!</span><br></pre></td></tr></table></figure><p>但是这段程序在调用方法DoSomething()、打印了“DoSomething invoked”之后，触发了事件，随后必须等订阅者的三个方法全部执行完毕了之后，也就是大概5秒钟的时间，才能继续执行下面的语句，也就是打印“Control back to client”。而我们前面说过，很多情况下，尤其是远程调用的时候（比如说在Remoting中），发布者和订阅者应该是完全的松耦合，发布者不关心谁订阅了它、不关心订阅者的方法有什么返回值、不关心订阅者会不会抛出异常，当然也不关心订阅者需要多长时间才能完成订阅的方法，它只要在事件发生的那一瞬间告知订阅者事件已经发生并将相关参数传给订阅者就可以了。然后它就应该继续执行它后面的动作，在本例中就是打印“Control back to client！”。<strong>而订阅者不管失败或是超时都不应该影响到发布者，但在上面的例子中，发布者却不得不等待订阅者的方法执行完毕才能继续运行</strong>。</p><p>现在我们来看下如何解决这个问题，先回顾一下之前我在C#中的委托和事件一文中提到的内容，我说过，委托的定义会生成继承自MulticastDelegate的完整的类，其中包含Invoke()、BeginInvoke()和EndInvoke()方法。当我们直接调用委托时，实际上是调用了Invoke()方法，它会中断调用它的客户端，然后在客户端线程上执行所有订阅者的方法（客户端无法继续执行后面代码），最后将控制权返回客户端。注意到BeginInvoke()、EndInvoke()方法，在.Net中，异步执行的方法通常都会配对出现，并且以Begin和End作为方法的开头（最常见的可能就是Stream类的BeginRead()和EndRead()方法了）。它们用于方法的异步执行，即是在调用BeginInvoke()之后，客户端从线程池中抓取一个闲置线程，然后交由这个线程去执行订阅者的方法，而客户端线程则可以继续执行下面的代码。</p><p>BeginInvoke()接受“动态”的参数个数和类型，为什么说“动态”的呢？因为它的参数是在编译时根据委托的定义动态生成的，其中前面参数的个数和类型与委托定义中接受的参数个数和类型相同，最后两个参数分别是AsyncCallback和Object类型，对于它们更具体的内容，可以参见下一节委托和方法的异步调用部分。现在，我们仅需要对这两个参数传入null就可以了。另外还需要注意几点：</p><ol><li>在委托类型上调用BeginInvoke()时，此委托对象只能包含一个目标方法，所以对于多个订阅者注册的情况，必须使用GetInvocationList()获得所有委托对象，然后遍历它们，分别在其上调用BeginInvoke()方法。如果直接在委托上调用BeginInvoke()，会抛出异常，提示“委托只能包含一个目标方法”。</li><li>如果订阅者的方法抛出异常，.NET会捕捉到它，但是只有在调用EndInvoke()的时候，才会将异常重新抛出。而在本例中，我们不使用EndInvoke()（因为我们不关心订阅者的执行情况），所以我们无需处理异常，因为即使抛出异常，也是在另一个线程上，不会影响到客户端线程（客户端甚至不知道订阅者发生了异常，这有时是好事有时是坏事）。</li><li>BeginInvoke()方法属于委托定义所生成的类，它既不属于MulticastDelegate也不属于Delegate基类，所以无法继续使用可重用的FireEvent()方法，我们需要进行一个向下转换，来获取到实际的委托类型。</li></ol><p>现在我们修改一下上面的程序，使用异步调用来解决订阅者方法执行超时的情况：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program6</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Publisher pub = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub1.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub2.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub3.OnEvent);</span><br><span class="line"></span><br><span class="line">        pub.DoSomething();      <span class="comment">// 触发事件</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Control back to client!\n"</span>); <span class="comment">// 返回控制权</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Press any thing to exit..."</span>);</span><br><span class="line">        Console.ReadKey();      <span class="comment">// 暂停客户程序，提供时间供订阅者完成方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;         </span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        Console.WriteLine(<span class="string">"DoSomething invoked!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">            Delegate[] delArray = MyEvent.GetInvocationList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">                EventHandler method = (EventHandler)del;</span><br><span class="line">                method.BeginInvoke(<span class="literal">null</span>, EventArgs.Empty, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">3</span>));      <span class="comment">// 模拟耗时三秒才能完成方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Waited for 3 seconds, subscriber1 invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Subsciber2 Failed"</span>);   <span class="comment">// 即使抛出异常也不会影响到客户端</span></span><br><span class="line">        <span class="comment">//Console.WriteLine("Subscriber2 immediately Invoked!");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));  <span class="comment">// 模拟耗时两秒才能完成方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Waited for 2 seconds, subscriber3 invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会得到下面的输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DoSomething invoked!</span><br><span class="line">Control back to client!</span><br><span class="line"></span><br><span class="line">Press any thing to exit...</span><br><span class="line"></span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">2</span> seconds, subscriber3 invoked!</span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">3</span> seconds, subscriber1 invoked!</span><br></pre></td></tr></table></figure><p>需要注意代码输出中的几个变化：</p><ol><li>我们需要在客户端程序中调用Console.ReadKey()方法来暂停客户端，以提供足够的时间来让异步方法去执行完代码，不然的话客户端的程序到此处便会运行结束，程序会退出，不会看到任何订阅者方法的输出，因为它们根本没来得及执行完毕。原因是这样的：客户端所在的线程我们通常称为主线程，而执行订阅者方法的线程来自线程池，属于后台线程(Background Thread），当主线程结束时，不论后台线程有没有结束，都会退出程序。（当然还有一种前台线程(Foreground Thread)，主线程结束后必须等前台线程也结束后程序才会退出，关于线程的讨论可以开辟另一个庞大的主题，这里就不讨论了）。</li><li>在打印完“Press any thing to exit…”之后，两个订阅者的方法会以2秒、1秒的间隔显示出来，且尽管我们先注册了subscirber1，但是却先执行了subscriber3，这是因为执行它需要的时间更短。除此以外，注意到这两个方法是并行执行的，所以执行它们的总时间是最长的方法所需要的时间，也就是3秒，而不是他们的累加5秒。</li><li>如同前面所提到的，尽管subscriber2抛出了异常，我们也没有针对异常进行处理，但是客户程序并没有察觉到，程序也没有因此而中断。</li></ol><h2 id="委托和方法的异步调用"><a href="#委托和方法的异步调用" class="headerlink" title="委托和方法的异步调用"></a>委托和方法的异步调用</h2><p>通常情况下，如果需要异步执行一个耗时的操作，我们会新起一个线程，然后让这个线程去执行代码。但是对于每一个异步调用都通过创建线程来进行操作显然会对性能产生一定的影响，同时操作也相对繁琐一些。.Net中可以通过委托进行方法的异步调用，就是说客户端在异步调用方法时，本身并不会因为方法的调用而中断，而是从线程池中抓取一个线程去执行该方法，自身线程（主线程）在完成抓取线程这一过程之后，继续执行下面的代码，这样就实现了代码的并行执行。使用线程池的好处就是避免了频繁进行异步调用时创建、销毁线程的开销。</p><p>如同上面所示，当我们在委托对象上调用BeginInvoke()时，便进行了一个异步的方法调用。<strong>上面的例子中是在事件的发布和订阅这一过程中使用了异步调用，而在事件发布者和订阅者之间往往是松耦合的，发布者通常不需要获得订阅者方法执行的情况；而当使用异步调用时，更多情况下是为了提升系统的性能，而并非专用于事件的发布和订阅这一编程模型</strong>。而在这种情况下使用异步编程时，就需要进行更多的控制，比如当异步执行方法的方法结束时通知客户端、返回异步执行方法的返回值等。本节就对BeginInvoke()方法、EndInvoke()方法和其相关的IAysncResult做一个简单的介绍。</p><div class="note info">            <p><strong>注意：</strong>注意此处我已经不再使用发布者、订阅者这些术语，因为我们不再是讨论上面的事件模型，而是讨论在客户端程序中异步地调用方法，这里有一个思维的转变。</p>          </div><p>我们看这样一段代码，它演示了不使用异步调用的通常情况：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program7</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Client application started!\n"</span>);</span><br><span class="line">        Thread.CurrentThread.Name = <span class="string">"Main Thread"</span>;</span><br><span class="line"></span><br><span class="line">        Calculator cal = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> result = cal.Add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"Result: &#123;0&#125;\n"</span>, result); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做某些其它的事情，模拟需要执行3秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;: Client executed &#123;1&#125; second(s)."</span>,</span><br><span class="line">                Thread.CurrentThread.Name, i);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"\nPress any key to exit..."</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.CurrentThread.IsThreadPoolThread) &#123;</span><br><span class="line">            Thread.CurrentThread.Name = <span class="string">"Pool Thread"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">"Method invoked!"</span>);           </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行某些事情，模拟需要执行2秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;: Add executed &#123;1&#125; second(s)."</span>, </span><br><span class="line">                Thread.CurrentThread.Name, i);  </span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">"Method complete!"</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有几个关于对于线程的操作，如果不了解可以看一下下面的说明，如果你已经了解可以直接跳过：</p><ol><li>Thread.Sleep()，它会让执行当前代码的线程暂停一段时间（如果你对线程的概念比较陌生，可以理解为使程序的执行暂停一段时间），以毫秒为单位，比如Thread.Sleep(1000)，将会使线程暂停1秒钟。在上面我使用了它的重载方法，个人觉得使用TimeSpan.FromSeconds(1)，可读性更好一些。</li><li>Thread.CurrentThread.Name，通过这个属性可以设置、获取执行当前代码的线程的名称，值得注意的是这个属性只可以设置一次，如果设置两次，会抛出异常。</li><li>Thread.IsThreadPoolThread，可以判断执行当前代码的线程是否为线程池中的线程。</li></ol><p>通过这几个方法和属性，有助于我们更好地调试异步调用方法。上面代码中除了加入了一些对线程的操作以外再没有什么特别之处。我们建了一个Calculator类，它只有一个Add方法，我们模拟了这个方法需要执行2秒钟时间，并且每隔一秒进行一次输出。而在客户端程序中，我们使用result变量保存了方法的返回值并进行了打印。随后，我们再次模拟了客户端程序接下来的操作需要执行2秒钟时间。运行这段程序，会产生下面的输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Client application started!</span><br><span class="line"></span><br><span class="line">Method invoked!</span><br><span class="line">Main Thread: Add executed <span class="number">1</span> second(s).</span><br><span class="line">Main Thread: Add executed <span class="number">2</span> second(s).</span><br><span class="line">Method complete!</span><br><span class="line">Result: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Main Thread: Client executed <span class="number">1</span> second(s).</span><br><span class="line">Main Thread: Client executed <span class="number">2</span> second(s).</span><br><span class="line">Main Thread: Client executed <span class="number">3</span> second(s).</span><br><span class="line"></span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure><p>如果你确实执行了这段代码，会看到这些输出并不是一瞬间输出的，而是执行了大概5秒钟的时间，因为线程是串行执行的，所以在执行完Add()方法之后才会继续客户端剩下的代码。</p><p>接下来我们定义一个AddDelegate委托，并使用BeginInvoke()方法来异步地调用它。在上面已经介绍过，BeginInvoke()除了最后两个参数为AsyncCallback类型和Object类型以外，前面的参数类型和个数与委托定义相同。另外BeginInvoke()方法返回了一个实现了IAsyncResult接口的对象（实际上就是一个AsyncResult类型实例，注意这里IAsyncResult和AysncResult是不同的，它们均包含在.Net Framework中）。</p><p>AsyncResult的用途有这么几个：传递参数，它包含了对调用了BeginInvoke()的委托的引用；它还包含了BeginInvoke()的最后一个Object类型的参数；它可以鉴别出是哪个方法的哪一次调用，因为通过同一个委托变量可以对同一个方法调用多次。</p><p>EndInvoke()方法接受IAsyncResult类型的对象（以及ref和out类型参数，这里不讨论了，对它们的处理和返回值类似），所以在调用BeginInvoke()之后，我们需要保留IAsyncResult，以便在调用EndInvoke()时进行传递。这里最重要的就是EndInvoke()方法的返回值，它就是方法的返回值。除此以外，当客户端调用EndInvoke()时，如果异步调用的方法没有执行完毕，则会中断当前线程而去等待该方法，只有当异步方法执行完毕后才会继续执行后面的代码。所以在调用完BeginInvoke()后立即执行EndInvoke()是没有任何意义的。我们通常在尽可能早的时候调用BeginInvoke()，然后在需要方法的返回值的时候再去调用EndInvoke()，或者是根据情况在晚些时候调用。说了这么多，我们现在看一下使用异步调用改写后上面的代码吧：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">AddDelegate</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program8</span> &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Client application started!\n"</span>);</span><br><span class="line">        Thread.CurrentThread.Name = <span class="string">"Main Thread"</span>;</span><br><span class="line">                    </span><br><span class="line">        Calculator cal = <span class="keyword">new</span> Calculator();</span><br><span class="line">        AddDelegate del = <span class="keyword">new</span> AddDelegate(cal.Add);</span><br><span class="line">        IAsyncResult asyncResult = del.BeginInvoke(<span class="number">2</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>);  <span class="comment">// 异步调用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做某些其它的事情，模拟需要执行3秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;: Client executed &#123;1&#125; second(s)"</span>,</span><br><span class="line">                Thread.CurrentThread.Name, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rtn = del.EndInvoke(asyncResult);</span><br><span class="line">        Console.WriteLine(<span class="string">"Result: &#123;0&#125;\n"</span>, rtn);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"\nPress any key to exit..."</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span> &#123; <span class="comment">/* 与上面同，略 */</span>&#125;</span><br></pre></td></tr></table></figure><p>此时的输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Client application started!</span><br><span class="line"></span><br><span class="line">Method invoked!</span><br><span class="line">Main Thread: Client executed <span class="number">1</span> second(s)</span><br><span class="line">Pool Thread: Add executed <span class="number">1</span> second(s)</span><br><span class="line">Main Thread: Client executed <span class="number">2</span> second(s)</span><br><span class="line">Pool Thread: Add executed <span class="number">2</span> second(s)</span><br><span class="line">Method complete!</span><br><span class="line">Main Thread: Client executed <span class="number">3</span> second(s)</span><br><span class="line">Result: <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure><p>现在执行完这段代码只需要3秒钟时间，两个for循环所产生的输出交替进行，这也说明了这两段代码并行执行的情况。可以看到Add()方法是由线程池中的线程在执行，因为Thread.CurrentThread.IsThreadPoolThread返回了True，同时我们对该线程命名为了Pool Thread。另外我们可以看到通过EndInvoke()方法得到了返回值。</p><p>有时候，我们可能会将获得返回值的操作放到另一段代码或者客户端去执行，而不是向上面那样直接写在BeginInvoke()的后面。比如说我们在Program中新建一个方法GetReturn()，此时可以通过AsyncResult的AsyncDelegate获得del委托对象，然后再在其上调用EndInvoke()方法，这也说明了AsyncResult可以唯一的获取到与它相关的调用了的方法（或者也可以理解成委托对象）。所以上面获取返回值的代码也可以改写成这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetReturn</span>(<span class="params">IAsyncResult asyncResult</span>)</span> &#123;</span><br><span class="line">    AsyncResult result = (AsyncResult)asyncResult;</span><br><span class="line">    AddDelegate del = (AddDelegate)result.AsyncDelegate;</span><br><span class="line">    <span class="keyword">int</span> rtn = del.EndInvoke(asyncResult);</span><br><span class="line">    <span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再将int rtn = del.EndInvoke(asyncResult);语句改为int rtn = GetReturn(asyncResult);。注意上面IAsyncResult要转换为实际的类型AsyncResult才能访问AsyncDelegate属性，因为它没有包含在IAsyncResult接口的定义中。</p><p>BeginInvoke的另外两个参数分别是AsyncCallback和Object类型，其中AsyncCallback是一个委托类型，它用于方法的回调，即是说当异步方法执行完毕时自动进行调用的方法。它的定义为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">AsyncCallback</span>(<span class="params">IAsyncResult ar</span>)</span>;</span><br></pre></td></tr></table></figure><p>Object类型用于传递任何你想要的数值，它可以通过IAsyncResult的AsyncState属性获得。下面我们将获取方法返回值、打印返回值的操作放到了OnAddComplete()回调方法中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">AddDelegate</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program9</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Client application started!\n"</span>);</span><br><span class="line">        Thread.CurrentThread.Name = <span class="string">"Main Thread"</span>;</span><br><span class="line"></span><br><span class="line">        Calculator cal = <span class="keyword">new</span> Calculator();</span><br><span class="line">        AddDelegate del = <span class="keyword">new</span> AddDelegate(cal.Add);</span><br><span class="line">        <span class="keyword">string</span> data = <span class="string">"Any data you want to pass."</span>;</span><br><span class="line">        AsyncCallback callBack = <span class="keyword">new</span> AsyncCallback(OnAddComplete);</span><br><span class="line">        del.BeginInvoke(<span class="number">2</span>, <span class="number">5</span>, callBack, data);      <span class="comment">// 异步调用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做某些其它的事情，模拟需要执行3秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;: Client executed &#123;1&#125; second(s)."</span>,</span><br><span class="line">                Thread.CurrentThread.Name, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"\nPress any key to exit..."</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnAddComplete</span>(<span class="params">IAsyncResult asyncResult</span>)</span> &#123;</span><br><span class="line">        AsyncResult result = (AsyncResult)asyncResult;</span><br><span class="line">        AddDelegate del = (AddDelegate)result.AsyncDelegate;</span><br><span class="line">        <span class="keyword">string</span> data = (<span class="keyword">string</span>)asyncResult.AsyncState;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rtn = del.EndInvoke(asyncResult);</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125;: Result, &#123;1&#125;; Data: &#123;2&#125;\n"</span>, </span><br><span class="line">            Thread.CurrentThread.Name, rtn, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span> &#123; <span class="comment">/* 与上面同，略 */</span>&#125;</span><br></pre></td></tr></table></figure><p>它产生的输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Client application started!</span><br><span class="line"></span><br><span class="line">Method invoked!</span><br><span class="line">Main Thread: Client executed <span class="number">1</span> second(s).</span><br><span class="line">Pool Thread: Add executed <span class="number">1</span> second(s).</span><br><span class="line">Main Thread: Client executed <span class="number">2</span> second(s).</span><br><span class="line">Pool Thread: Add executed <span class="number">2</span> second(s).</span><br><span class="line">Method complete!</span><br><span class="line">Pool Thread: Result, <span class="number">7</span>; Data: Any data you want to pass.</span><br><span class="line"></span><br><span class="line">Main Thread: Client executed <span class="number">3</span> second(s).</span><br><span class="line"></span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure><p>这里有几个值得注意的地方：</p><ol><li>我们在调用BeginInvoke()后不再需要保存IAysncResult了，因为AysncCallback委托将该对象定义在了回调方法的参数列表中；</li><li>我们在OnAddComplete()方法中获得了调用BeginInvoke()时最后一个参数传递的值，字符串“Any data you want to pass”；</li><li>执行回调方法的线程并非客户端线程Main Thread，而是来自线程池中的线程Pool Thread。另外如前面所说，在调用EndInvoke()时有可能会抛出异常，所以在应该将它放到try/catch块中，这里我就不再示范了。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是对我之前写的C#中的委托和事件的一个补充，大致分为了三个部分，第一部分讲述了几个容易让人产生困惑的问题：为什么使用事件而不是委托变量，为什么通常委托的定义都返回void；第二部分讲述了如何处理异常和超时；第三部分则讲述了通过委托实现异步方法的调用。</p><div class="note info">            <p>免责声明：<br>本文转自网络文章，转载此文章仅为个人收藏，分享知识，如有侵权，请联系博主进行删除。<br>原文：<a href="http://www.tracefact.net/tech/029.html" target="_blank" rel="noopener" title="张子阳的博客">张子阳的博客 - C#中的委托和事件 - Part.2</a> 原文地址：<a href="http://www.tracefact.net/tech/029.html" target="_blank" rel="noopener">http://www.tracefact.net/tech/029.html</a></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CSharp </tag>
            
            <tag> 事件 </tag>
            
            <tag> 委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 事件和委托 - Part.1</title>
      <link href="/2020/07/04/CSharpEventDelegate01/"/>
      <url>/2020/07/04/CSharpEventDelegate01/</url>
      
        <content type="html"><![CDATA[<div class="note info">            <p><strong>注意：</strong>文中代码在VS2005下通过，由于VS2003(.Net Framework 1.1)不支持隐式的委托变量，所以如果在一个接受委托类型的位置直接赋予方法名，在VS2003下会报错，解决办法是显式的创建一个委托类型的实例(委托变量)。例如：委托类型 委托实例 = new 委托类型(方法名);</p>          </div><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。</p><h2 id="将方法作为方法的参数"><a href="#将方法作为方法的参数" class="headerlink" title="将方法作为方法的参数"></a>将方法作为方法的参数</h2><p>我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//做某些额外的事情，比如初始化之类，此处略</span></span><br><span class="line">    EnglishGreeting(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Morning, "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。</p><p>现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"早上好, "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Language </span><br><span class="line">&#123;</span><br><span class="line">    English, Chinese</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, Language lang</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//做某些额外的事情，比如初始化之类，此处略</span></span><br><span class="line">    swith(lang) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> Language.English:</span><br><span class="line">            EnglishGreeting(name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Language.Chinese:</span><br><span class="line">            ChineseGreeting(name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。</p><p>在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, Language lang</span>)</span></span><br></pre></td></tr></table></figure><p>我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。</p><p>如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MakeGreeting(name);</span><br></pre></td></tr></table></figure><p>好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, *** MakeGreeting</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：<strong>这个代表着方法的MakeGreeting参数应该是什么类型的？</strong></p><div class="note info">            <p><strong>提示：</strong>这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。</p>          </div><p>聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br></pre></td></tr></table></figure><p>如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。<strong>MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。</strong></p><p>于是，委托出现了：<strong>它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。</strong></p><div class="note info">            <p><strong>提示：</strong>如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的<strong>值的种类</strong>，也就是name参数的类型。</p>          </div><p>本例中委托的定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure><p>可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？</p><p>现在，让我们再次改动GreetPeople()方法，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义委托，它定义了可以代表的方法的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Morning, "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"早上好, "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意此方法，它接受一个GreetingDelegate类型的方法作为参数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            MakeGreeting(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            GreetPeople(<span class="string">"Jimmy Zhang"</span>, EnglishGreeting);</span><br><span class="line">            GreetPeople(<span class="string">"张子阳"</span>, ChineseGreeting);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure><p>我们现在对委托做一个总结：</p><p><strong>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</strong></p><h2 id="将方法绑定到委托"><a href="#将方法绑定到委托" class="headerlink" title="将方法绑定到委托"></a>将方法绑定到委托</h2><p>看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> name1, name2;</span><br><span class="line">    name1 = <span class="string">"Jimmy Zhang"</span>;</span><br><span class="line">    name2 = <span class="string">"张子阳"</span>;</span><br><span class="line">    GreetPeople(name1, EnglishGreeting);</span><br><span class="line">    GreetPeople(name2, ChineseGreeting);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingDelegate delegate1, delegate2;</span><br><span class="line">    delegate1 = EnglishGreeting;</span><br><span class="line">    delegate2 = ChineseGreeting;</span><br><span class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);</span><br><span class="line">    GreetPeople(<span class="string">"张子阳"</span>, delegate2);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting;<span class="comment">//先给委托类型的变量赋值</span></span><br><span class="line">    delegate1 += ChineseGreeting;<span class="comment">//给此委托变量再绑定一个方法</span></span><br><span class="line">    <span class="comment">//将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure><p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting;<span class="comment">//先给委托类型的变量赋值</span></span><br><span class="line">    delegate1 += ChineseGreeting;<span class="comment">//给此委托变量再绑定一个方法</span></span><br><span class="line">    <span class="comment">//将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    delegate1(<span class="string">"Jimmy Zhang"</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p><strong>注意：</strong>这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。</p>          </div><p>注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。</p><p>我们也可以使用下面的代码来这样简化这一过程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</span><br><span class="line">delegate1 += ChineseGreeting;<span class="comment">//给此委托变量再绑定一个方法</span></span><br></pre></td></tr></table></figure><p>看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate();</span><br><span class="line">delegate1 += EnglishGreeting;<span class="comment">//这次用的是 “+=”，绑定语法。</span></span><br><span class="line">delegate1 += ChineseGreeting;<span class="comment">//给此委托变量再绑定一个方法</span></span><br></pre></td></tr></table></figure><p>但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。</p><p><strong>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</span><br><span class="line">    delegate1 += ChineseGreeting;<span class="comment">//给此委托变量再绑定一个方法</span></span><br><span class="line">    <span class="comment">//将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    delegate1 -= EnglishGreeting;<span class="comment">//取消对EnglishGreeting方法的绑定</span></span><br><span class="line">    <span class="comment">//将仅调用 ChineseGreeting </span></span><br><span class="line">    GreetPeople(<span class="string">"张子阳"</span>, delegate1);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure><p>让我们再次对委托作个总结：</p><p><strong>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。</strong></p><h2 id="事件的由来"><a href="#事件的由来" class="headerlink" title="事件的由来"></a>事件的由来</h2><p>我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫GreetingManager的类中，那么新程序应该是这个样子的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义委托，它定义了可以代表的方法的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">    <span class="comment">//新建的GreetingManager类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            MakeGreeting(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Morning, "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"早上好, "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//... ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingManager gm = <span class="keyword">new</span> GreetingManager();</span><br><span class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, EnglishGreeting);</span><br><span class="line">    gm.GreetPeople(<span class="string">"张子阳"</span>, ChineseGreeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure><p>现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingManager gm = <span class="keyword">new</span> GreetingManager();</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting;</span><br><span class="line">    delegate1 += ChineseGreeting;</span><br><span class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure><p>到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在GreetingManager类的内部声明delegate1变量</span></span><br><span class="line">    <span class="keyword">public</span> GreetingDelegate delegate1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MakeGreeting(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以这样使用这个委托变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingManager gm = <span class="keyword">new</span> GreetingManager();</span><br><span class="line">    gm.delegate1 = EnglishGreeting;</span><br><span class="line">    gm.delegate1 += ChineseGreeting;</span><br><span class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, gm.delegate1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure><p>尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, gm.delegate1);</span><br></pre></td></tr></table></figure><p>既然如此，我们何不修改 GreetingManager 类成这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在GreetingManager类的内部声明delegate1变量</span></span><br><span class="line">    <span class="keyword">public</span> GreetingDelegate delegate1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(delegate1 != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果有方法注册委托变量</span></span><br><span class="line">            delegate1(name);</span><br><span class="line">            <span class="comment">//通过委托调用方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端，调用看上去更简洁一些：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingManager gm = <span class="keyword">new</span> GreetingManager();</span><br><span class="line">    gm.delegate1 = EnglishGreeting;</span><br><span class="line">    gm.delegate1 += ChineseGreeting;</span><br><span class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>);</span><br><span class="line">    <span class="comment">//注意，这次不需要再传递 delegate1变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure><p>尽管这样达到了我们要的效果，但是还是存在着问题：</p><p>在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。</p><p>我们先看看如果把 delegate1 声明为 private会怎样？结果就是：<strong>这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？</strong></p><p>再看看把delegate1 声明为 public 会怎样？结果就是：<strong>在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。</strong></p><p>最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，<strong>不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？</strong></p><p>现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？<strong>答案是使用属性对字段进行封装。</strong></p><p>于是，Event出场了，它封装了委托类型的变量，使得：<strong>在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。</strong></p><p>我们改写GreetingManager类，它变成了这个样子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这一次我们在这里声明一个事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> GreetingDelegate MakeGreet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MakeGreet(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：<strong>事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</strong></p><p>为了证明上面的推论，如果我们像下面这样改写Main方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GreetingManager gm = <span class="keyword">new</span> GreetingManager();</span><br><span class="line">    gm.MakeGreet = EnglishGreeting;</span><br><span class="line">    <span class="comment">//编译错误1</span></span><br><span class="line">    gm.MakeGreet += ChineseGreeting;</span><br><span class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。</p><h2 id="事件和委托的编译代码"><a href="#事件和委托的编译代码" class="headerlink" title="事件和委托的编译代码"></a>事件和委托的编译代码</h2><p>这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> GreetingDelegate MakeGreet;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ShenHaoCode/ImageHostingService/20200714/025.gif" alt=""><br>可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。</p><p>我们再进一步看下MakeGreet所产生的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> GreetingDelegate MakeGreet;</span><br><span class="line"><span class="comment">//对事件的声明 实际是 声明一个私有的委托变量</span></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.Synchronized)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_MakeGreet</span>(<span class="params">GreetingDelegate <span class="keyword">value</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.MakeGreet = (GreetingDelegate) Delegate.Combine(<span class="keyword">this</span>.MakeGreet, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.Synchronized)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove_MakeGreet</span>(<span class="params">GreetingDelegate <span class="keyword">value</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.MakeGreet = (GreetingDelegate) Delegate.Remove(<span class="keyword">this</span>.MakeGreet, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经很明确了：<strong>MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。</strong>实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。</p><p>在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure><p>当编译器遇到这段代码的时候，会生成下面这样一个完整的类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public sealed class GreetingDelegate: System.MulticastDelegate </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">object</span> @<span class="keyword">object</span>, IntPtr method</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IAsyncResult <span class="title">BeginInvoke</span>(<span class="params"><span class="keyword">string</span> name, AsyncCallback callback, <span class="keyword">object</span> @<span class="keyword">object</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndInvoke</span>(<span class="params">IAsyncResult result</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ShenHaoCode/ImageHostingService/20200714/026.gif" alt=""></p><p>关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。</p><h2 id="委托、事件与Observer设计模式"><a href="#委托、事件与Observer设计模式" class="headerlink" title="委托、事件与Observer设计模式"></a>委托、事件与Observer设计模式</h2><h3 id="范例说明"><a href="#范例说明" class="headerlink" title="范例说明"></a>范例说明</h3><p>上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：</p><p>假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。</p><p>现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Heater</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> temperature;</span><br><span class="line">        <span class="comment">//水温</span></span><br><span class="line">        <span class="comment">//烧水</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                temperature = i;</span><br><span class="line">                <span class="keyword">if</span>(temperature &gt; <span class="number">95</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    MakeAlert(temperature);</span><br><span class="line">                    ShowMsg(temperature);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发出语音警报</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="keyword">int</span> param</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了："</span>, param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示水温</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="keyword">int</span> param</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Display：水快开了，当前温度：&#123;0&#125;度。"</span>, param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Heater ht = <span class="keyword">new</span> Heater();</span><br><span class="line">            ht.BoilWater();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Observer设计模式简介"><a href="#Observer设计模式简介" class="headerlink" title="Observer设计模式简介"></a>Observer设计模式简介</h3><p>上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。</p><p>这时候，上面的例子就应该变成这个样子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//热水器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> temperature;</span><br><span class="line">    <span class="comment">//烧水</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            temperature = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//警报器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="keyword">int</span> param</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了："</span> , param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="keyword">int</span> param</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Display：水已烧开，当前温度：&#123;0&#125;度。"</span> , param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：</p><ol><li>Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。</li><li>Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。</li></ol><p>在本例中，事情发生的顺序应该是这样的：</p><ol><li>警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。</li><li>热水器知道后保留对警报器和显示器的引用。</li><li>热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。</li></ol><p>类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。</p><h3 id="实现范例的Observer设计模式"><a href="#实现范例的Observer设计模式" class="headerlink" title="实现范例的Observer设计模式"></a>实现范例的Observer设计模式</h3><p>我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//热水器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> temperature;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">BoilHandler</span>(<span class="params"><span class="keyword">int</span> param</span>)</span>;</span><br><span class="line">        <span class="comment">//声明委托</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> BoilHandler BoilEvent;</span><br><span class="line">        <span class="comment">//声明事件</span></span><br><span class="line">        <span class="comment">//烧水</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                temperature = i;</span><br><span class="line">                <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (BoilEvent != <span class="literal">null</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果有对象注册</span></span><br><span class="line">                        BoilEvent(temperature);</span><br><span class="line">                        <span class="comment">//调用所有注册对象的方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//警报器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="keyword">int</span> param</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了："</span>, param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="keyword">int</span> param</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//静态方法</span></span><br><span class="line">            Console.WriteLine(<span class="string">"Display：水快烧开了，当前温度：&#123;0&#125;度。"</span>, param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">            Alarm alarm = <span class="keyword">new</span> Alarm();</span><br><span class="line">            heater.BoilEvent += alarm.MakeAlert;</span><br><span class="line">            <span class="comment">//注册方法</span></span><br><span class="line">            heater.BoilEvent += (<span class="keyword">new</span> Alarm()).MakeAlert;</span><br><span class="line">            <span class="comment">//给匿名对象注册方法</span></span><br><span class="line">            heater.BoilEvent += Display.ShowMsg;</span><br><span class="line">            <span class="comment">//注册静态方法</span></span><br><span class="line">            heater.BoilWater();</span><br><span class="line">            <span class="comment">//烧水，会自动调用注册过对象的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alarm：嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Alarm：嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Display：水快烧开了，当前温度：<span class="number">96</span>度。</span><br><span class="line"><span class="comment">//省略...</span></span><br></pre></td></tr></table></figure><h2 id="Net-Framework中的委托与事件"><a href="#Net-Framework中的委托与事件" class="headerlink" title=".Net Framework中的委托与事件"></a>.Net Framework中的委托与事件</h2><p>尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？</p><p>在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：</p><ol><li>委托类型的名称都应该以EventHandler结束。</li><li>委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。</li><li>事件的命名为 委托去掉 EventHandler之后剩余的部分。</li><li>继承自EventArgs的类型应该以EventArgs结尾。</li></ol><p>再做一下说明：</p><ol><li>委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。</li><li>EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。</li></ol><p><strong>上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。</strong>比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。</p><p>现在我们改写之前的范例，让它符合 .Net Framework 的规范：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//热水器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> temperature;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> type = <span class="string">"RealFire 001"</span>;</span><br><span class="line">        <span class="comment">//添加型号作为演示</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> area = <span class="string">"China Xian"</span>;</span><br><span class="line">        <span class="comment">//添加产地作为演示</span></span><br><span class="line">        <span class="comment">//声明委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">BoiledEventHandler</span>(<span class="params">Object sender, BoiledEventArgs e</span>)</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> BoiledEventHandler Boiled;</span><br><span class="line">        <span class="comment">//声明事件</span></span><br><span class="line">        <span class="comment">//定义BoiledEventArgs类，传递给Observer所感兴趣的信息</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoiledEventArgs</span> : <span class="title">EventArgs</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">int</span> temperature;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">BoiledEventArgs</span>(<span class="params"><span class="keyword">int</span> temperature</span>) </span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnBoiled</span>(<span class="params">BoiledEventArgs e</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boiled != <span class="literal">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果有对象注册</span></span><br><span class="line">                Boiled(<span class="keyword">this</span>, e);</span><br><span class="line">                <span class="comment">//调用所有注册对象的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//烧水。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                temperature = i;</span><br><span class="line">                <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//建立BoiledEventArgs 对象。</span></span><br><span class="line">                    BoiledEventArgs e = <span class="keyword">new</span> BoiledEventArgs(temperature);</span><br><span class="line">                    OnBoiled(e);</span><br><span class="line">                    <span class="comment">//调用 OnBolied方法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//警报器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params">Object sender, Heater.BoiledEventArgs e</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Heater heater = (Heater)sender;</span><br><span class="line">            <span class="comment">//这里是不是很熟悉呢？</span></span><br><span class="line">            <span class="comment">//访问 sender 中的公共字段</span></span><br><span class="line">            Console.WriteLine(<span class="string">"Alarm：&#123;0&#125; - &#123;1&#125;: "</span>, heater.area, heater.type);</span><br><span class="line">            Console.WriteLine(<span class="string">"Alarm: 嘀嘀嘀，水已经 &#123;0&#125; 度了："</span>, e.temperature);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params">Object sender, Heater.BoiledEventArgs e</span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//静态方法</span></span><br><span class="line">            Heater heater = (Heater)sender;</span><br><span class="line">            Console.WriteLine(<span class="string">"Display：&#123;0&#125; - &#123;1&#125;: "</span>, heater.area, heater.type);</span><br><span class="line">            Console.WriteLine(<span class="string">"Display：水快烧开了，当前温度：&#123;0&#125;度。"</span>, e.temperature);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">            Alarm alarm = <span class="keyword">new</span> Alarm();</span><br><span class="line">            heater.Boiled += alarm.MakeAlert;</span><br><span class="line">            <span class="comment">//注册方法</span></span><br><span class="line">            heater.Boiled += (<span class="keyword">new</span> Alarm()).MakeAlert;</span><br><span class="line">            <span class="comment">//给匿名对象注册方法</span></span><br><span class="line">            heater.Boiled += <span class="keyword">new</span> Heater.BoiledEventHandler(alarm.MakeAlert);</span><br><span class="line">            <span class="comment">//也可以这么注册</span></span><br><span class="line">            heater.Boiled += Display.ShowMsg;</span><br><span class="line">            <span class="comment">//注册静态方法</span></span><br><span class="line">            heater.BoilWater();</span><br><span class="line">            <span class="comment">//烧水，会自动调用注册过对象的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Alarm：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Alarm：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Alarm：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Display：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Display：水快烧开了，当前温度：<span class="number">96</span>度。</span><br><span class="line"><span class="comment">//省略 ...</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中我首先通过一个GreetingPeople的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。</p><p>在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 Observer设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。</p><p>感谢阅读，希望这篇文章能给你带来帮助！</p><div class="note info">            <p>免责声明：<br>本文转自网络文章，转载此文章仅为个人收藏，分享知识，如有侵权，请联系博主进行删除。<br>原文：<a href="http://www.tracefact.net/tech/009.html" target="_blank" rel="noopener" title="张子阳的博客">张子阳的博客 - C#中的委托和事件 - Part.1</a> 原文地址：<a href="http://www.tracefact.net/tech/009.html" target="_blank" rel="noopener">http://www.tracefact.net/tech/009.html</a></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CSharp </tag>
            
            <tag> 事件 </tag>
            
            <tag> 委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server</title>
      <link href="/2020/07/03/SQLServerNotes/"/>
      <url>/2020/07/03/SQLServerNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h2><p>SQL Server 是Microsoft 公司推出的关系型数据库管理系统。<br>SQL 是用于访问和处理数据库的标准的计算机语言</p><h3 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(9)  <span class="keyword">SELECT</span> </span><br><span class="line">(<span class="number">10</span>) DISTICNCT <span class="keyword">column</span>,</span><br><span class="line">(<span class="number">6</span>)  AGG_FUNC(<span class="keyword">column</span> <span class="keyword">or</span> expiression), ...</span><br><span class="line">(<span class="number">1</span>)  <span class="keyword">FROM</span> left_table</span><br><span class="line">     (<span class="number">3</span>) <span class="keyword">JOIN</span> right_table</span><br><span class="line">     (<span class="number">2</span>) <span class="keyword">ON</span> tablename.column = other_tablename.column</span><br><span class="line">(<span class="number">4</span>)  <span class="keyword">WHERE</span> constraint_expiression</span><br><span class="line">(<span class="number">5</span>)  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line">(<span class="number">7</span>)  <span class="keyword">WITH</span> <span class="keyword">CUBE</span>|<span class="keyword">ROLLUP</span></span><br><span class="line">(<span class="number">8</span>)  <span class="keyword">HAVING</span> constraint_expiression</span><br><span class="line">(<span class="number">11</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span>|<span class="keyword">DESC</span></span><br><span class="line">(<span class="number">12</span>) <span class="keyword">LIMIT</span> <span class="keyword">count</span> <span class="keyword">OFFSET</span> <span class="keyword">count</span>;</span><br></pre></td></tr></table></figure><p>从这个顺序中我们可以发现，所有的查询语句都是从 <strong>FROM</strong> 开始执行的。在实际执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。 接下来，我们详细的介绍下每个步骤的具体执行过程。</p><ol><li><p>FROM 执行笛卡尔积<br>FROM 才是 SQL 语句执行的第一步，并非 SELECT 。对 FROM 子句中的前两个表执行笛卡尔积 (交叉联接），生成虚拟表 VT1，获取不同数据源的数据集。<br><strong>FROM 子句执行顺序为从后往前、从右到左</strong>，FROM 子句中写在最后的表 (基础表 driving table) 将被最先处理，即最后的表为驱动表，当 FROM 子句中包含多个表的情况下，我们需要选择数据最少的表作为基础表。</p></li><li><p>ON 应用 ON 过滤器<br>对虚拟表 <strong>VT1</strong> 应用 ON 筛选器，ON 中的逻辑表达式将应用到虚拟表 <strong>VT1</strong> 中的各个行，筛选出满足 ON 逻辑表达式的行，生成虚拟表 <strong>VT2</strong> 。</p></li><li><p>JOIN 添加外部行<br>如果指定了 OUTER JOIN 保留表中未找到匹配的行将作为外部行添加到虚拟表 <strong>VT2</strong>，生成虚拟表 <strong>VT3</strong>。保留表如下：</p><ul><li>LEFT OUTER JOIN 把左表记为保留表</li><li>RIGHT OUTER JOIN 把右表记为保留表</li><li>FULL OUTER JOIN 把左右表都作为保留表</li></ul><p>在虚拟表 <strong>VT2</strong> 表的基础上添加保留表中被过滤条件过滤掉的数据，非保留表中的数据被赋予 NULL 值，最后生成虚拟表 <strong>VT3</strong>。<br>如果 FROM 子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤 1~3，直到处理完所有的表为止。</p></li><li><p>WHERE 应用 WEHRE 过滤器<br>对虚拟表 <strong>VT3</strong> 应用 WHERE 筛选器。根据指定的条件对数据进行筛选，并把满足的数据插入虚拟表 <strong>VT4</strong>。</p><ul><li>由于数据还没有分组，因此现在还不能在 WHERE 过滤器中使用聚合函数对分组统计的过滤。</li><li>同时，由于还没有进行列的选取操作，因此在 SELECT 中使用列的别名也是不被允许的。</li></ul></li><li><p>GROUP BY 分组<br>按 GROUP BY 子句中的列 / 列表将虚拟表 <strong>VT4</strong> 中的行唯一的值组合成为一组，生成虚拟表 VT5。如果应用了 GROUP BY，那么后面的所有步骤都只能得到的虚拟表 <strong>VT5</strong> 的列或者是聚合函数（count、sum、avg 等）。原因在于最终的结果集中只为每个组包含一行。<br>同时，从这一步开始，后面的语句中都可以使用 SELECT 中的别名。</p></li><li><p>AGG_FUNC 计算聚合函数<br>计算 max 等聚合函数。SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。常用的 Aggregate 函数包涵以下几种：</p><ul><li>AVG：返回平均值</li><li>COUNT：返回行数</li><li>FIRST：返回第一个记录的值</li><li>LAST：返回最后一个记录的值</li><li>MAX： 返回最大值</li><li>MIN：返回最小值</li><li>SUM： 返回总和</li></ul></li><li><p>WITH 应用 ROLLUP 或 CUBE<br>对虚拟表 <strong>VT5</strong> 应用 ROLLUP 或 CUBE 选项，生成虚拟表 <strong>VT6</strong>。<br>CUBE 和 ROLLUP 区别如下：</p><ul><li>CUBE 生成的结果数据集显示了所选列中值的所有组合的聚合。</li><li>ROLLUP 生成的结果数据集显示了所选列中值的某一层次结构的聚合。</li></ul></li><li><p>HAVING 应用 HAVING 过滤器<br>对虚拟表 <strong>VT6</strong> 应用 <strong>HAVING</strong> 筛选器。根据指定的条件对数据进行筛选，并把满足的数据插入虚拟表 <strong>VT7</strong>。<br><strong>HAVING</strong> 语句在 SQL 中的主要作用与 <strong>WHERE</strong> 语句作用是相同的，但是 <strong>HAVING</strong> 是过滤聚合值，在 SQL 中增加 HAVING 子句原因就是，WHERE 关键字无法与聚合函数一起使用，HAVING 子句主要和 GROUP BY 子句配合使用。</p></li><li><p>SELECT 选出指定列<br>将虚拟表 <strong>VT7</strong> 中的在 SELECT 中出现的列筛选出来，并对字段进行处理，计算 SELECT 子句中的表达式，产生虚拟表 <strong>VT8</strong>。</p></li><li><p>DISTINCT 行去重<br>将重复的行从虚拟表 <strong>VT8</strong> 中移除，产生虚拟表 <strong>VT9</strong>。DISTINCT 用来删除重复行，只保留唯一的。</p></li><li><p>ORDER BY 排列<br>将虚拟表 <strong>VT9</strong> 中的行按 ORDER BY 子句中的列 / 列表排序，生成游标 <strong>VC10</strong> ，注意不是虚拟表。因此使用 ORDER BY 子句查询不能应用于表达式。同时，ORDER BY 子句的执行顺序为从左到右排序，是非常消耗资源的。</p></li><li><p>LIMIT/OFFSET 指定返回行<br>从 <strong>VC10</strong> 的开始处选择指定数量行，生成虚拟表 <strong>VT11</strong>，并返回调用者。</p></li></ol><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">-1</span>, <span class="keyword">GETDATE</span>())) + <span class="number">1</span>, <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">-1</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询上个月一号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">GETDATE</span>()), <span class="keyword">GETDATE</span>())<span class="comment">--查询上月月底</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">GETDATE</span>()) + <span class="number">1</span>, <span class="keyword">GETDATE</span>())<span class="comment">--查询本月一号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>())), <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询本月底</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>())) + <span class="number">1</span>, <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">1</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询下月一号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, -<span class="keyword">DAY</span>(<span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">2</span>, <span class="keyword">GETDATE</span>())), <span class="keyword">DATEADD</span>(<span class="keyword">MONTH</span>, <span class="number">2</span>, <span class="keyword">GETDATE</span>()))<span class="comment">--查询下月月底</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT</span>(<span class="built_in">VARCHAR</span>(<span class="number">7</span>), <span class="keyword">GETDATE</span>(), <span class="number">120</span>)</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- =============================================</span></span><br><span class="line"><span class="comment">-- Author: &lt;Author,,Name&gt;</span></span><br><span class="line"><span class="comment">-- Create date: &lt;Create Date,,2020-07-04&gt;</span></span><br><span class="line"><span class="comment">-- Description:&lt;Description,,拆分字符串&gt;</span></span><br><span class="line"><span class="comment">-- =============================================</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> [dbo].[FUN_SplitToTable]</span><br><span class="line">(</span><br><span class="line">    @SplitString <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>),</span><br><span class="line">    @Separator <span class="keyword">NVARCHAR</span>(<span class="number">10</span>) = <span class="string">''</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">RETURNS</span> @SplitStringsTable <span class="keyword">TABLE</span></span><br><span class="line">(</span><br><span class="line">    [<span class="keyword">ID</span>] <span class="built_in">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    [<span class="keyword">VALUE</span>] <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>) <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @CurrentIndex <span class="built_in">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> @NextIndex <span class="built_in">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> @ReturnText <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>);</span><br><span class="line">    <span class="keyword">SET</span> @CurrentIndex = <span class="number">1</span>;</span><br><span class="line">    WHILE @CurrentIndex &lt;= LEN(@SplitString)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">SET</span> @NextIndex = <span class="keyword">CHARINDEX</span>(@Separator, @SplitString, @CurrentIndex);</span><br><span class="line">        IF @NextIndex = 0 OR @NextIndex IS NULL</span><br><span class="line">        <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="keyword">SELECT</span> @NextIndex = <span class="keyword">LEN</span>(@SplitString) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">SELECT</span> @ReturnText = <span class="keyword">SUBSTRING</span>(@SplitString, @CurrentIndex, @NextIndex - @CurrentIndex);</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> @SplitStringsTable ( [<span class="keyword">VALUE</span>] ) <span class="keyword">VALUES</span> ( @ReturnText );</span><br><span class="line">            <span class="keyword">SELECT</span> @CurrentIndex = @NextIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">RETURN</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> SQL Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2020/06/26/HexoNotes/"/>
      <url>/2020/06/26/HexoNotes/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
